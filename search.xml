<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java面向对象设计之适配器模式]]></title>
    <url>%2Fblogs%2F157566173.html</url>
    <content type="text"><![CDATA[模式动机 在软件开发中采用类似于电源适配器的设计和编码技巧被称为适配器模式。 通常情况下，客户端可以通过目标类的接口访问它所提供的服务。有时，现有的类可以满足客户类的功能需要，但是它所提供的接口不一定是客户类所期望的，这可能是因为现有类中方法名与目标类中定义的方法名不一致等原因所导致的。 在这种情况下，现有的接口需要转化为客户类期望的接口，这样保证了对现有类的重用。如果不进行这样的转化，客户类就不能利用现有类所提供的功能，适配器模式可以完成这样的转化。 在适配器模式中可以定义一个包装类，包装不兼容接口的对象，这个包装类指的就是适配器(Adapter)，它所包装的对象就是适配者(Adaptee)，即被适配的类。 适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。 模式定义 适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。适配器模式是一种结构型模式。 模式结构参与角色适配器模式包含如下角色： Target：目标抽象类 Adapter：适配器类 Adaptee：适配者类 Client：客户类 UML类图 代码示例首先，是目标角色接口和具体目标实现类： /** * Target 目标角色类. * * @author blinkfox on 2018-12-11. */ public interface Target { /** * 目标角色自己的方法. */ void request(); } /** * 具体的目标角色实现类. * * @author blinkfox on 2018-12-11. */ public class ConcreteTarget implements Target { /** * 目标角色自己的方法. */ @Override public void request() { System.out.println("hello, I'm concrete target method."); } } 其次，是适配者类： /** * 适配者类. * * @author blinkfox on 2018-12-11. */ public class Adaptee { /** * 这是原有的业务逻辑方法. */ public void doSomething() { System.out.println("Hello, I'm Adaptee method."); } } 然后，是适配器角色类： /** * 适配器类. * * @author blinkfox on 2018-12-11. */ public class Adapter extends Adaptee implements Target { /** * 适配了目标角色自己的方法. */ @Override public void request() { super.doSomething(); System.out.println("适配器适配了目标角色方法."); } } 最后，是客户端场景类： /** * 客户端场景类. * * @author blinkfox on 2018-12-11. */ public class Client { /** * main方法. * * @param args 数组参数 */ public static void main(String[] args) { // 原有业务逻辑. Target target = new ConcreteTarget(); target.request(); // 增加了适配器角色后的业务逻辑. Target adaptTarget = new Adapter(); adaptTarget.request(); } } 模式分析适用环境在以下情况下可以使用适配器模式： 系统需要使用现有的类，而这些类的接口不符合系统的需要。 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。 优点 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。 增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。 缺点如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。 模式应用Sun公司在1996年公开了Java语言的数据库连接工具JDBC，JDBC使得Java语言程序能够与数据库连接，并使用SQL语言来查询和操作数据。JDBC给出一个客户端通用的抽象接口，每一个具体数据库引擎（如SQL Server、Oracle、MySQL等）的JDBC驱动软件都是一个介于JDBC接口和数据库引擎接口之间的适配器软件。抽象的JDBC接口和各个数据库引擎API之间都需要相应的适配器软件，这就是为各个不同数据库引擎准备的驱动程序。 总结 结构型模式描述如何将类或者对象结合在一起形成更大的结构。 适配器模式用于将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 适配器模式包含四个角色：目标抽象类定义客户要用的特定领域的接口；适配器类可以调用另一个接口，作为一个转换器，对适配者和抽象目标类进行适配，它是适配器模式的核心；适配者类是被适配的角色，它定义了一个已经存在的接口，这个接口需要适配；在客户类中针对目标抽象类进行编程，调用在目标抽象类中定义的业务方法。 在类适配器模式中，适配器类实现了目标抽象类接口并继承了适配者类，并在目标抽象类的实现方法中调用所继承的适配者类的方法；在对象适配器模式中，适配器类继承了目标抽象类并定义了一个适配者类的对象实例，在所继承的目标抽象类方法中调用适配者类的相应业务方法。 适配器模式的主要优点是将目标类和适配者类解耦，增加了类的透明性和复用性，同时系统的灵活性和扩展性都非常好，更换适配器或者增加新的适配器都非常方便，符合“开闭原则”；类适配器模式的缺点是适配器类在很多编程语言中不能同时适配多个适配者类，对象适配器模式的缺点是很难置换适配者类的方法。 适配器模式适用情况包括：系统需要使用现有的类，而这些类的接口不符合系统的需要；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类一起工作。 参考自：适配器模式]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式之建造者模式]]></title>
    <url>%2Fblogs%2F2173505135.html</url>
    <content type="text"><![CDATA[一、模式动机无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有多个组成部分，如汽车，它包括车轮、方向盘、发动机等各种部件。而对于大多数用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车，可以通过建造者模式对其进行设计与描述，建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。 在软件开发中，也存在大量类似汽车一样的复杂对象，它们拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象。而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。 复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称作建造者的对象里，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机。 二、模式定义 造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式属于对象创建型模式。建造者模式又可以称为生成器模式。 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。 三、模式结构1. 角色组成建造者模式包含如下角色： Builder：抽象建造者 ConcreteBuilder：具体建造者 Director：导演者 Product：产品角色 2. 结构图 四、示例代码首先，是产品类： /** * 产品类. * * Created by blinkfox on 2016/10/8. */ public class Product { private String part1; private String part2; /* getter 和 setter方法. */ public String getPart1() { return part1; } public void setPart1(String part1) { this.part1 = part1; } public String getPart2() { return part2; } public void setPart2(String part2) { this.part2 = part2; } } 其实，是抽象的建造者Builder接口和具体的建造者ConcreteBuilder类： /** * 抽象的建造者. * * Created by blinkfox on 2016/10/8. */ public interface Builder { /** * 产品建造部分1. */ void buildPart1(); /** * 产品建造部分2. */ void buildPart2(); /** * 得到建造的产品. * * @return 产品 */ Product getResult(); } /** * 具体的建造者实现类. * * Created by blinkfox on 2016/10/8. */ public class ConcreteBuilder implements Builder { /** 产品. */ private Product product = new Product(); /** * 产品建造部分1. */ @Override public void buildPart1() { product.setPart1("编号：95757"); } /** * 产品建造部分2. */ @Override public void buildPart2() { product.setPart2("名称：小机器人"); } /** * 得到建造的产品. * * @return 产品 */ @Override public Product getResult() { return product; } } 最后，导演者Director类： /** * 导演者类. * * Created by blinkfox on 2016/10/8. */ public class Director { /** 当前需要的建造者对象. */ private Builder builder; /** * 构造方法. * * @param builder */ public Director(Builder builder) { this.builder = builder; } /** * 产品构造方法，负责调用各个零件建造方法. */ public void construct() { builder.buildPart1(); builder.buildPart2(); } } 以下是建造者模式的客户端场景类： /** * 建造者模式的客户端场景类. * * Created by blinkfox on 2016/10/8. */ public class BuilderClient { /** * 主入口方法. * * @param args 数组参数 */ public static void main(String[] args) { Builder builder = new ConcreteBuilder(); Director director = new Director(builder); director.construct(); Product product = builder.getResult(); System.out.println(product.getPart1()); System.out.println(product.getPart2()); } } 五、模式分析抽象建造者类中定义了产品的创建方法和返回方法; 建造者模式的结构中还引入了一个导演者类Director，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。导演者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过导演者类调用建造者的相关方法，返回一个完整的产品对象 在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现。 1. 优点建造者模式的优点： 在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。 2. 缺点建造者模式的缺点： 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。 3. 适用环境在以下情况下可以使用建造者模式： 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。 对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。 4. 建造者模式与抽象工厂模式的比较 与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。 在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。 如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。 六、模式总结 建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。 建造者模式包含如下四个角色：抽象建造者为创建一个产品对象的各个部件指定抽象接口；具体建造者实现了抽象建造者接口，实现各个部件的构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象；产品角色是被构建的复杂对象，包含多个组成部件；指挥者负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造 在建造者模式的结构中引入了一个导演者类，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。 建造者模式的主要优点在于客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象，每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，符合“开闭原则”，还可以更加精细地控制产品的创建过程；其主要缺点在于由于建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，因此其使用范围受到一定的限制，如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。 建造者模式适用情况包括：需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性；需要生成的产品对象的属性相互依赖，需要指定其生成顺序；对象的创建过程独立于创建该对象的类；隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同类型的产品。]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式之单例模式]]></title>
    <url>%2Fblogs%2F606353581.html</url>
    <content type="text"><![CDATA[模式动机对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器。 如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。 一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。 模式定义 单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。 单例模式的要点有三个： 一是某个类只能有一个实例； 二是它必须自行创建这个实例； 三是它必须自行向整个系统提供这个实例。 模式结构参与角色 Singleton: 单例 UML类图 时序图 代码实现方式1. 饿汉式（推荐使用）/** * 饿汉式单例模式. * * @author blinkfox on 2017-10-23. */ public class Singleton { /** 全局唯一实例. */ private static final Singleton singleton = new Singleton(); private Singleton() {} public static Singleton getSingleton() { return singleton; } } 注：这种方式避免了多线程的同步问题，但不是懒加载。如果不需要懒加载的方式，推荐使用。 2. 非线程安全懒汉式（不推荐使用）/** * 非线程安全的懒汉式. * * @author blinkfox on 2017-10-23. */ public class Singleton { private static Singleton singleton; private Singleton() {} /** * 通过懒加载的方式获取实例，但是非线程安全. * @return Singleton实例 */ public static Singleton getSingleton() { if (singleton == null) { singleton = new Singleton(); } return singleton; } } 注：是懒加载的方式，但非线程安全。不推荐使用。 3. 低效的线程安全懒汉式（不推荐使用）/** * 低效的线程安全的懒汉式. * * @author blinkfox on 2017-10-23. */ public class Singleton { private static Singleton singleton; private Singleton() {} /** * 通过 synchronized 关键字来保证线程安全，也是懒加载的方式来获取实例. * @return Singleton实例 */ public static synchronized Singleton getSingleton() { if (singleton == null) { singleton = new Singleton(); } return singleton; } } 注：是懒加载的方式，也线程安全，但是效率很低。因为99%的情况下是不需要去同步的。不推荐使用。 4. 双重校验锁线程安全懒汉式（不推荐使用）/** * 双重校验锁线程安全懒汉式. * * @author blinkfox on 2017-10-23. */ public class Singleton { private static Singleton singleton; private Singleton() {} /** * 通过'双重校验锁'来更高效的保证线程安全，也是懒加载的方式来获取实例. * @return Singleton实例 */ public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } 注：是懒加载的方式，也线程安全，效率也不错。但受限于Jdk5以前的Java内存模型，仍然会有bug，Java5及之后才能正常达到单例效果。 5. 枚举式（强烈推荐使用）/** * 枚举方式的单例. * * @author blinkfox on 2017-10-23. */ public enum Singleton { INSTANCE; } 注：在《Effective Java》一书中强烈推荐使用枚举来实现单例模式，该方式简单可自由序列化；保证只有一个实例（即使使用反射机制也无法多次实例化一个枚举量）；线程安全。唯一的缺点是非懒加载方式。 6. 静态内部类（推荐使用）/** * 通过使用静态内部类的方式来实现懒加载且线程安全的创建单例. * * @author blinkfox on 2017-10-23. */ public class Singleton { private Singleton() {} /** * 静态内部类. */ private static final class SingletonHolder { private SingletonHolder() {} private static Singleton4 instance = new Singleton(); } /** * 通过懒加载的方式获取Singleton唯一实例的方法. * @return Singleton实例 */ public static Singleton getInstance() { return SingletonHolder.instance; } } 注：这种方式利用了ClassLoader的机制保证初始化instance时只有一个线程，其只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。 模式分析单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式包含的角色只有一个，就是单例类——Singleton。 优点 提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。 允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。 缺点 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。 适用环境在以下情况下可以使用单例模式： 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。 在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式。 总结 单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。 单例模式只包含一个单例角色：在单例类的内部实现只生成一个实例，同时它提供一个静态的工厂方法，让客户可以使用它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有。 实现单例模式，如果不需要懒加载的效果，则推荐使用枚举和饿汉式的方式；如果需要懒加载的效果，则推荐使用静态内部类来实现更好。 单例模式的主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重。 单例模式适用情况包括：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点。]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式之工厂模式]]></title>
    <url>%2Fblogs%2F2168237024.html</url>
    <content type="text"><![CDATA[一、模式定义工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 二、模式结构1. 角色组成工厂方法模式包含如下角色： Product：抽象产品 ConcreteProduct：具体产品 Factory：抽象工厂 ConcreteFactory：具体工厂 2. 结构图 3. 时序图 三、示例代码首先，是抽象的产品类和具体的产品类： /** * 抽象产品类 * Created by blinkfox on 16-6-29. */ public abstract class Product { /** * 产品类的公共方法 */ public void method1() { System.out.println("这是产品类的公共方法"); } /** * 抽象方法 */ public abstract void method2(); } /** * 具体产品类1 * Created by blinkfox on 16-6-29. */ public class ConcreteProduct1 extends Product { @Override public void method2() { System.out.println("ConcreteProduct1的method2方法"); } } /** * 具体产品类2 * Created by blinkfox on 16-6-29. */ public class ConcreteProduct2 extends Product { @Override public void method2() { System.out.println("ConcreteProduct2的method2方法"); } } 然后，是抽象的工厂类和具体的工厂类： /** * 抽象的工厂类 * Created by blinkfox on 16-6-29. */ public abstract class Factory { /** * 运用了Java中的泛型和反射技术,生成某种具体的产品 * 其输入类型可以自行设置 * @param c * @param &lt;T> * @return */ public abstract &lt;T extends Product> T createProduct(Class&lt;T> c); } /** * 具体生产产品的工厂类 * Created by blinkfox on 16-6-29. */ public class ConcreteFactory extends Factory { /** * 运用了Java中的泛型和反射技术,生成某种具体的产品 * 其输入类型可以自行设置 * @param c * @param &lt;T> * @return */ @Override public &lt;T extends Product> T createProduct(Class&lt;T> c) { Product product = null; try { product = (Product) Class.forName(c.getName()).newInstance(); } catch (Exception e) { System.out.println("生产产品出错"); e.printStackTrace(); } return (T) product; } } 最后，是客户端场景类： /** * 工厂方法模式客户端场景类 * Created by blinkfox on 16-6-29. */ public class Client { public static void main(String[] args) { Factory factory = new ConcreteFactory(); Product product1 = factory.createProduct(ConcreteProduct1.class); product1.method1(); product1.method2(); Product product2 = factory.createProduct(ConcreteProduct2.class); product2.method1(); product2.method2(); } } 四、模式分析在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。 1. 优点工厂方法模式的优点： 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。 2. 缺点工厂方法模式的缺点： 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。 3. 适用环境在以下情况下可以使用工厂方法模式： 一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。 一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。 五、模式扩展工厂方法模式有很多扩展，而且与其他模式结合使用威力更大，下面介绍4种常用扩展。 1. 简单工厂模式我们这样考虑一个问题：一个模块仅需要一个工厂类，没有必要把它产生出来，使用静态的方法就可以了。因此去掉工厂类中继承的抽象类，把方法改成静态即可。通用代码如下： /** * 简单工厂模式中的工厂类 * Created by blinkfox on 16-6-29. */ public class SimpleFactory { /** * 运用了Java中的泛型和反射技术,生成某种具体的产品 * 其输入类型可以自行设置 * @param c * @param &lt;T> * @return */ public static &lt;T extends Product> T createProduct(Class&lt;T> c) { Product product = null; try { product = (Product) Class.forName(c.getName()).newInstance(); } catch (Exception e) { System.out.println("生产产品出错"); e.printStackTrace(); } return (T) product; } } /** * 简单工厂模式客户端场景类 * Created by blinkfox on 16-6-29. */ public class SimpleClient { public static void main(String[] args) { Product product1 = SimpleFactory.createProduct(ConcreteProduct1.class); product1.method1(); product1.method2(); Product product2 = SimpleFactory.createProduct(ConcreteProduct2.class); product2.method1(); product2.method2(); } } 运行结果没有发生变化，但是类图简单了，调用者也比较简单，简单工厂模式是工厂方法模式的弱化，也叫做静态工厂模式。其缺点是工厂类的扩展比较困难，不符合“开闭原则”，但它仍然是一个非常实用的设计模式。 2. 多工厂类工厂方法模式当我们在一个比较复杂的项目时，经常会遇到初始化一个对象很耗费精力的情况，所有的产品类都放到一个工厂方法中进行初始化会使代码结构不清晰。为了让结构清晰，我们就为每类产品定义一个创造者，然后由调用者自己去选择与哪个工厂方法关联。多工厂模式的通用代码如下： 多工厂模式的抽象工厂类： /** * 生成多个产品的抽象工厂类 * Created by blinkfox on 16-7-2. */ public abstract class MultiFactory { /** * 生成某种产品的方法 * @return */ public abstract Product createProduct(); } 第一种产品的创建工厂实现： /** * 生成产品1的具体工厂类1 * Created by blinkfox on 16-7-2. */ public class ConcreteFactory1 extends MultiFactory { /** * 生成产品1的方法 * @return */ @Override public Product createProduct() { return new ConcreteProduct1(); } } 第二种产品的创建工厂实现： /** * 生成产品2的具体工厂类2 * Created by blinkfox on 16-7-2. */ public class ConcreteFactory2 extends MultiFactory { /** * 生成产品2的方法 * @return */ @Override public Product createProduct() { return new ConcreteProduct2(); } } 多工厂模式的客户端场景类 /** * 多工厂方法模式客户端场景类 * Created by blinkfox on 16-7-2. */ public class MultiClient { public static void main(String[] args) { Product concreteProduct1 = (new ConcreteFactory1()).createProduct(); concreteProduct1.method1(); concreteProduct1.method2(); Product concreteProduct2 = (new ConcreteFactory2()).createProduct(); concreteProduct1.method1(); concreteProduct1.method2(); } } 3. 工厂方法的单例模式单例模式的核心要求就是在内存中只有一个对象，通过工厂方法模式也可以只在内存中生成一个对象，从而实现单例的功能。 下面是单例类，其中定义了一个private的无参构造函数，目的是不允许通过new的方式创建对象，代码如下： /** * 工厂方法模式中的单例类 * Created by blinkfox on 16-7-4. */ public class Singleton { /** * 私有化构造方法，不允许new产生一个对象 */ private Singleton() {} /** * 工厂方法模式中的单例模式业务方法 */ public void doSomething() { System.out.println("工厂方法模式中的单例模式方法。。。"); } } 以上单例类中不能通过正常的渠道建立一个对象，那单例的工厂类中如何建立一个单例对象呢？答案是通过反射方式创建，单例工厂类的代码如下： /** * 生成单例的工厂类 * Created by blinkfox on 16-7-4. */ public class SingletonFactory { private static Singleton singleton; static { try { Class c = Class.forName(Singleton.class.getName()); // 获得无参构造 Constructor constructor = c.getDeclaredConstructor(); // 设置无参构造是可访问的 constructor.setAccessible(true); // 产生一个实例对象 singleton = (Singleton) constructor.newInstance(); } catch (Exception e) { e.printStackTrace(); System.out.println("生成单例的工厂类方法中生成单例出错");zuihou } } public static Singleton getSingleton() { return singleton; } } 最后是工厂方法单例模式的客户端场景类： /** * 工厂方法单例模式客户端场景类 * Created by blinkfox on 16-7-4. */ public class SingleClient { public static void main(String[] args) { Singleton singleton = SingletonFactory.getSingleton(); singleton.doSomething(); } } 4. 工厂方法的延迟初始化何为延迟初始化？一个对象被消费完毕后，并不立即释放，工厂类保持其初始状态，等待再次使用。延迟初始化是工厂模式的一个扩展应用，其通用代码如下： /** * 延迟加载的工厂类 * Created by blinkfox on 16-7-4. */ public class LazyFactory { private static final Map&lt;String, Product> lazyMap = new HashMap&lt;String, Product>(); public static synchronized Product createProduct(String type) { Product product = null; // 如果map中已经有这个对象，则直接取出该对象即可，否则创建并放在缓存容器中 if (lazyMap.containsKey(type)) { return lazyMap.get(type); } // 根据类型创建具体的产品对象 if ("product1".equals(type)) { product = new ConcreteProduct1(); } else { product = new ConcreteProduct2(); } // 同时把对象放到缓存容器中 lazyMap.put("type", product); return product; } } 上面即为延迟加载的工厂类。代码比较简单，通过定义一个map容器来容纳所有产生的对象，如果在map容器中已经有的对象，则直接取出返回；如果没有，则根据需要的类型产生一个对象并放入到map容器中，以便下次调用。 延迟加载的工厂模式客户端场景类代码如下： /** * 延迟加载的工厂模式客户端场景类 * Created by blinkfox on 16-7-4. */ public class LazyClient { public static void main(String[] args) { Product product1 = LazyFactory.createProduct("product1"); Product product11 = LazyFactory.createProduct("product1"); } } 六、总结 工厂方法模式又称为工厂模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 工厂方法模式包含四个角色：抽象产品是定义产品的接口，是工厂方法模式所创建对象的超类型，即产品对象的共同父类或接口；具体产品实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，它们之间往往一一对应；抽象工厂中声明了工厂方法，用于返回一个产品，它是工厂方法模式的核心，任何在模式中创建对象的工厂类都必须实现该接口；具体工厂是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户调用，返回一个具体产品类的实例。 工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。 工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。 工厂方法模式适用情况包括：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式之状态模式]]></title>
    <url>%2Fblogs%2F1603223013.html</url>
    <content type="text"><![CDATA[一、模式动机在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(stateful)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。 二、模式定义 状态模式(State Pattern)：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。 三、模式结构1. 角色组成：状态模式包含如下角色： Context: 环境类 State: 抽象状态角色 ConcreteState: 具体状态角色类 2. 结构图： 3. 时序图： 四、示例代码首先，是抽象的状态角色接口： /** * 抽象状态角色 * Created by blinkfox on 16/7/12. */ public interface IState { /** * 抽象方法1 */ void handle1(); /** * 抽象方法2 */ void handle2(); } 接下来，是多个具体的状态角色类，分别如下： /** * 具体状态角色类1 * Created by blinkfox on 16/7/12. */ public class ConcreteState1 implements IState { /** * 具体状态角色类1中的方法1 */ @Override public void handle1() { System.out.println("执行了具体状态角色类1中的方法1..."); } /** * 具体状态角色类1中的方法2 */ @Override public void handle2() { System.out.println("执行了具体状态角色类1中的方法2..."); } } /** * 具体状态角色类2 * Created by blinkfox on 16/7/12. */ public class ConcreteState2 implements IState { /** * 具体状态角色类2中的方法1 */ @Override public void handle1() { System.out.println("执行了具体状态角色类2中的方法1..."); } /** * 具体状态角色类2中的方法2 */ @Override public void handle2() { System.out.println("执行了具体状态角色类2中的方法2..."); } } 然后，是环境类： /** * 环境角色类 * Created by blinkfox on 16/7/12. */ public class Context { // 当前状态 private IState state; /** * 构造方法 * @param state */ public Context(IState state) { this.state = state; } /** * 方法1 */ public void handle1() { this.state.handle1(); } /** * 方法2 */ public void handle2() { this.state.handle2(); } } 最后，是用于测试状态模式的客户端场景类： /** * 状态模式的客户端场景累 * Created by blinkfox on 16/7/12. */ public class StateClient { public static void main(String[] args) { Context context = new Context(new ConcreteState1()); context.handle1(); context.handle2(); } } 五、模式分析 状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。 状态模式的关键是引入了一个抽象接口来专门表示对象的状态，这个类我们叫做抽象状态接口，而对象的每一种具体状态类都实现了该类，并在不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换。 在状态模式结构中需要理解环境类与抽象状态类的作用： 环境类实际上就是拥有状态的对象，环境类有时候可以充当状态管理器(State Manager)的角色，可以在环境类中对状态进行切换操作。 抽象状态类可以是抽象类，也可以是接口，不同状态类就是继承这个父类的不同子类，状态类的产生是由于环境类存在多个状态，同时还满足两个条件： 这些状态经常需要切换，在不同的状态下对象的行为不同。因此可以将不同对象下的行为单独提取出来封装在具体的状态类中，使得环境类对象在其内部状态改变时可以改变它的行为，对象看起来似乎修改了它的类，而实际上是由于切换到不同的具体状态类实现的。由于环境类可以设置为任一具体状态类，因此它针对抽象状态类进行编程，在程序运行时可以将任一具体状态类的对象设置到环境类中，从而使得环境类可以改变内部状态，并且改变行为。 1. 优点状态模式的优点： 封装了转换规则。 枚举可能的状态，在枚举状态之前需要确定状态种类。 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 2. 缺点状态模式的缺点： 状态模式的使用必然会增加系统类和对象的个数。 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。 3.适用环境在以下情况下可以使用状态模式： 对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。 代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。 状态模式在工作流或游戏等类型的软件中得以广泛使用，甚至可以用于这些系统的核心功能设计，如在政府OA办公系统中，一个批文的状态有多种：尚未办理；正在办理；正在批示；正在审核；已经完成等各种状态，而且批文状态不同时对批文的操作也有所差异。使用状态模式可以描述工作流对象（如批文）的状态转换以及不同状态下它所具有的行为。 六、总结 状态模式允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象，状态模式是一种对象行为型模式。 状态模式包含三个角色：环境类又称为上下文类，它是拥有状态的对象，在环境类中维护一个抽象状态类State的实例，这个实例定义当前状态，在具体实现时，它是一个State子类的对象，可以定义初始状态；抽象状态类用于定义一个接口以封装与环境类的一个特定状态相关的行为；具体状态类是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同。 状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。 状态模式的主要优点在于封装了转换规则，并枚举可能的状态，它将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为，还可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数；其缺点在于使用状态模式会增加系统类和对象的个数，且状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，对于可以切换状态的状态模式不满足“开闭原则”的要求。 状态模式适用情况包括：对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为；代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式之策略模式]]></title>
    <url>%2Fblogs%2F2812777186.html</url>
    <content type="text"><![CDATA[一、模式动机完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。 在软件系统中，有许多算法可以实现某一功能，如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。 除了提供专门的查找算法类之外，还可以在客户端程序中直接包含算法代码，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。 为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类。 二、模式定义 策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。 策略模式是一种对象行为型模式。 三、 模式结构策略模式包含如下角色： Context: 环境类 Strategy: 抽象策略类 ConcreteStrategy: 具体策略类 结构图 时序图 四、示例代码首先定义一个策略接口： public interface IStrategy { /** * 策略模式的运算法则 */ public void doSomething(); } 然后是具体的策略实现类： public class ConcreteStrategy1 implements IStrategy { @Override public void doSomething() { System.out.println("具体策略的策略方法1"); } } public class ConcreteStrategy2 implements IStrategy { @Override public void doSomething() { System.out.println("具体策略的策略方法2"); } } 接着是封装角色的类： public class Context { // 抽象策略 private IStrategy strategy; /** * 构造函数设置具体策略 * @param strategy */ public Context(IStrategy strategy) { this.strategy = strategy; } /** * 封装后的策略方法 */ public void doAnything() { this.strategy.doSomething(); } } 最后是客户端的调用策略类： public class Client { public static void main(String[] args) { // 声明一个具体的策略 IStrategy strategy = new ConcreteStrategy1(); // 声明上下文对象 Context context = new Context(strategy); // 执行封装后的方法 context.doAnything(); } } 五、模式分析总体分析 策略模式是一个比较容易理解和使用的设计模式，策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。 在策略模式中，应当由客户端自己决定在什么情况下使用什么具体策略角色。 策略模式仅仅封装算法，提供新算法插入到已有系统中，以及老算法从系统中“退休”的方便，策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定。这在一定程度上提高了系统的灵活性，但是客户端需要理解所有具体策略类之间的区别，以便选择合适的算法，这也是策略模式的缺点之一，在一定程度上增加了客户端的使用难度。 优点策略模式的优点： 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基- 础上选择算法或行为，也可以灵活地增加新的算法或行为。 策略模式提供了管理相关的算法族的办法。 策略模式提供了可以替换继承关系的办法。 使用策略模式可以避免使用多重条件转移语句。 缺点策略模式的缺点： 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。 适用环境在以下情况下可以使用策略模式： 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 一个系统需要动态地在几种算法中选择一种。 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。 不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性。 模式扩展策略模式与状态模式： 可以通过环境类状态的个数来决定是使用策略模式还是状态模式。 策略模式的环境类自己选择一个具体策略类，具体策略类无须关心环境类；而状态模式的环境类由于外在因素需要放进一个具体状态中，以便通过其方法实现状态的切换，因此环境类和状态类之间存在一种双向的关联关系。 使用策略模式时，客户端需要知道所选的具体策略是哪一个，而使用状态模式时，客户端无须关心具体状态，环境类的状态会根据用户的操作自动转换。 如果系统中某个类的对象存在多种状态，不同状态下行为有差异，而且这些状态之间可以发生转换时使用状态模式；如果系统中某个类的某一行为存在多种实现方式，而且这些实现方式可以互换时使用策略模式。 六、总结 在策略模式中定义了一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式。策略模式是一种对象行为型模式。 策略模式包含三个角色：环境类在解决某个问题时可以采用多种策略，在环境类中维护一个对抽象策略类的引用实例；抽象策略类为所支持的算法声明了抽象方法，是所有策略类的父类；具体策略类实现了在抽象策略类中定义的算法。 策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。 策略模式主要优点在于对“开闭原则”的完美支持，在不修改原有系统的基础上可以更换算法或者增加新的算法，它很好地管理算法族，提高了代码的复用性，是一种替换继承，避免多重条件转移语句的实现方式；其缺点在于客户端必须知道所有的策略类，并理解其区别，同时在一定程度上增加了系统中类的个数，可能会存在很多策略类。 策略模式适用情况包括：在一个系统里面有许多类，它们之间的区别仅在于它们的行为，使用策略模式可以动态地让一个对象在许多行为中选择一种行为；一个系统需要动态地在几种算法中选择一种；避免使用难以维护的多重条件选择语句；希望在具体策略类中封装算法和与相关的数据结构。]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象编程的理解]]></title>
    <url>%2Fblogs%2F2369825694.html</url>
    <content type="text"><![CDATA[面向过程和面向对象面向过程思想概述面向着具体的每一个步骤和过程，把每一个步骤和过程完成，然后由这些功能方法相互调用，完成需求。 面向对象思想概述当需求单一，或者简单时，我们一步一步去操作没问题，并且效率也挺高。可随着需求的更改，功能的增多，发现需要面对每一个步骤很麻烦了，这时就开始思索，能不能把这些步骤和功能在进行封装，封装时根据不同的功能，进行不同的封装，功能类似的封装在一起。这样结构就清晰了很多。用的时候，找到对应的类就可以了。这就是面向对象的思想。面向对象是基于面向过程的编程思想。 面向对象特征 抽象 封装 继承 多态 抽象把现实世界中的某一类东西，提取出来，用程序代码表示，抽象出来的一般叫做类或者接口。抽象并不打算了解全部问题，而是选择其中的一部分，暂时不用部分细节。抽象包括两个方面： 数据抽象：表示世界中一类事物的特征,就是对象的属性.比如鸟有翅膀,羽毛等(类的属性) 过程抽象：表示世界中一类事物的行为,就是对象的行为.比如鸟会飞,会叫(类的方法) 封装封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别；将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，以特定的访问权限来使用类的成员。隐藏之后，外部程序就不能接触和改变那些细节，所以不用担心自己的类会受到非法修改，可确保它们不会对其他程序造成影响。 封装的原则 将不需要对外提供的内容都隐藏起来 把属性都隐藏，提供公共方法对其访问 继承一种联结类的层次模型，并且允许和鼓励类的重用，提供一种明确表达共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类(子类)，原始类称为新类的基类(父类)。派生类可以从它的父类哪里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。因此可以说，继承为了重用父类代码，同时为实现多态性作准备。 继承概念的实现方式 类继承：类继承是指直接使用基类的属性和方法而无需额外编码。 接口继承：接口继承是指仅使用属性和方法的名称、但是子类必须提供实现。 多态多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。 实现多态的方式 重载 重写 实现接口 面向对象总结封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了代码重用。而多态则是为了实现另一个目的：接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。 面向对象开发就是不断的创建对象，使用对象，指挥对象做事情。 面向对象设计更好的管理和维护对象之间的关系。 面向对象优点 更符合我们思想习惯的思想 将复杂的事情简单化 将我们从执行者变成了指挥者]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码整洁之道]]></title>
    <url>%2Fblogs%2F793584201.html</url>
    <content type="text"><![CDATA[读了代码整洁之道，觉得这本书写的很好，所以就将里面自己觉得很经典的内容记录下来，作为自己以后写代码的标准和准则。同时也为那些曾经困惑过的人一点参考吧！ 一、在正式开始之前，我们先思考几个几个问题：1.需求与代码哪个重要？答：并不是所有的产品都能提出合理的需求，当你面对一个提出不合理需求的产品的时候，你需要坚持自己的原则，不能妥协。 2.易读和易懂是一回事吗？答：易读的代码和易懂的代码是有区别的，不是易读的代码就是易懂的代码。 3.什么是测试驱动代码？答：测试驱动代码，你写的代码要可以执行单元测试。如果你发现你的代码很难写单元测试，那么你就要思考你的代码是不是已经不整洁了，或者说已经乱成一团了。 4.什么是简单的代码？答：1.能通过所有测试2.没有重复代码3.体现系统中全部设计理念4.包含尽量少的实体，包括，类，函数，方法等 如果某段代码在程序设计中反复出现，就证明想法在代码中没有很好的体现出来。总之，不要重复代码，只做一件事，表达力，小规模抽象。 二、第二章 有意义的命名1.名副其实变量，函数或类的名称应该已经答复了所有的大问题。它应该告诉你，它为什么会存在，它做什么事情，应该怎么用。如果名称需要注释来补充，那么就不算名副其实。 2.避免误导必须避免留下掩藏代码本意的错误线索。 3.做有意义的区分只要体现出有意义的区分，使用a和the这样的前缀就没有错。废话就是冗余。 4.使用读得出来的名称不要用傻乎乎的自造词，而不是恰当的英语词。 5.使用可搜索的名称使用便于搜索的名字。 6.避免使用编码把类型或者作用域编进名称里面，徒然增加了解码的负担。没理由要求每位新人都在弄清要应付的代码之外，还要再搞懂另一种编码”语言”。 7.避免思维映射不应当让读者在脑中把你的名称翻译为他们熟知的名称，尤其是在经常出现在选择是使用问题领域术语还是解决方案领域术语的时候。 8.类名或对象名最好使用名词或者名词短语9.方法名最好使用动词或者动词短语10.别扮可爱命名一定要通俗易懂。 11.每一个概念对应一个词给每个抽象概念选择一个词，并一以贯之 12.别用双关语词避免将同一个词用于不同目的，遵循一词一义的原则 13.使用解决方案领域名14.使用源自所涉领域名15.添加有意义的语境在一个bean中定义变量名的时候，变量名一定是基于实际使用场景。 16.不要添加没用的语境三、第三章 函数1.短小函数第一规则是要短小。第二条规则是还要更短小。 2.只做一件事 函数应该做一件事。做好这件事。只做一件事。如果可以从你的函数中还能拆分出一个函数，该函数不仅只是单纯地重新诠释其实现，那么你设计的函数就不是一个好的函数。 函数中的区段，如果函数被切分了多个区段，这就证明该函数做的事情太多了。 3.每个函数一个抽象层级4.switch语句确保每个switch都埋藏在较低的抽象层级，而且永远不重复。 5.使用描述性的名称命名方式要保持一致。使用与模块名一脉相承的短语、名词和动词给函数命名。例如：includeSetupPages。 6.函数参数 最理想的函数参数的数量是零个，其次是一，再次是二，应尽量避免三。有足够的理由才能用上三个以上的参数。 如果函数看来需要两个，三个或者三个以上参数，就说明其中一些参数应该封装为类了。 函数和函数的参数命名一般是动名词比较好。 7.无副作用8.分割指令与查询函数要么做什么事，要么回答什么事，但二者不可兼得 9.使用异常替代返回错误码 返回错误码的时候，就是在要求调用者立刻处理错误。 如果使用异常替代返回错误码，错误处理代码就能从住路径代码中分离出来，得到简化。 抽离try/catch代码块 10.别重复自己11.结构化编程四、第四章 注释1.如果你代码写的足够好的话，可以让人一看就懂，那么你就不需要再写注释。如果你的代码需要注释，那么你就需要想想是不是你的表达水平有问题。2.真正好的注释是想办法不用写注释，那么什么样的注释需要写呢？ 法律信息 提供信息的注释 提供意图的解释 阐释 警告 TODO注释 TODO是一种程序要认为应该要做的，但是由于某种原因没有做的 放大,放大某些看似不合理的地方 五、第六章 对象和数据结构1.得墨忒定律模块不应该了解他所操作对象的内部情形。对象隐藏数据曝露操作，这就意味着对象不应该通过存取器曝露其内部结构。 六、第七章 错误处理1.将业务逻辑和出错处理一定要隔离开，但是并不是所有的情况都试用，在不适用的情况下我们可以创建一个配置对象将特殊情况给予返回。2.异常处理不能过多的曝露实现细节，主要提现在异常抛出的栈信息上。七、第八章 边界1.整洁的边界，边界上的代码要清晰的分割和定义了期望的测试。应该避免我们的代码过多地了解第三方代码中的特定信息。八、第九章 单元测试1.TDD三定律 在编写不能通过的单元测试前，不可编写生产代码。 只可编写刚好无法通过的单元测试，不能编译也算不通过 只可编写刚好足以通过当前失败测试的生产代码 2.整洁测试三要素 可读性 可读性 可读性 3.整洁测试的五条原则： 快速，测试应该够快 独立，测试应该相互独立 可重复，测试应当可在任何环境中重复通过。 自足验证，测试应该有布尔值输出，无论测试是成功还是失败，不应该人工通过log来确认测试是否成功或者失败。 及时，测试应及时编写。单元测试应该恰好在使其通过的生产代码之前编写。如果在编写生产代码之后编写测试，你会发现生产代码难以测试。你可能会认为某些生产代码本身难以测试。你可能不会去设计可测试的代码。 九、第十章 类1.单一权责原则，类或者模块应有且只有一条加以修改的理由。2.内聚，如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。内聚性高，意味着类中的方法和变量相互依赖，相互结合成一个逻辑整体。十、第十一章 系统1.将系统的构造与使用分开软件系统应将起始过程和启始过程之后的运行时逻辑分离开，在起始过程中构建应用对象，也会存在相互缠结的依赖关系。（延迟初始化可以加快程序运行速度） 1.1分解main将程序的构造放到main，并使其与运行时逻辑分开，main只管构造并将构造后的数据对象发送给各个应用，或者被各个应用使用。但是，不参与运行时的任何逻辑控制。 1.2工厂模式使用该模式可以将系统构造和系统运行时逻辑分开。 1.3依赖注入（需要强化理解）1.4扩容“一开始就做对系统”纯属神话。反之，我们应该只去实现今天的用户故事，然后重构，明天再扩展系统，实现新用户的故事。这就是迭代和增量敏捷的精髓所在。测试驱动开发，重构以及他们打造出的整洁的代码。 1.5测试驱动系统架构最佳的系统架构由模块化的关注面领域组成，每个关注面均用纯编程语言对象实现。不同的领域之间用最不具有侵害性的方面或类方面工具结合起来。这种架构就能测试驱动，就像代码一样。(需要关注面向切片编程(POJO)) 1.6优化决策模块化和关注面切分成就了分散化管理和决策。在巨大的系统中，不管是一座城市或是一个软件项目，无人能做所有的决策。最好是授权给最有资格的人。拥有模块化关注面的POJO系统提供的敏捷能力，允许我们基于最新的知识做出优化的，时机刚好的决策。决策的复杂性降低了。 十一、第十二章 迭进1. 通过迭进设计达到代码整洁的目的：通过这几个原则可以让你的设计变简单（DIP，SRP） 运行所有测试 不可重复， 表达了程序员的意图 尽可能减少类和方法的数量 以上规则按其重要程度排序 2. 简单设计规则1:运行所有测试编写的测试越多就越能持续走向编写较易测试的代码，紧耦合的代码很难编写测试。遵循有关编写测试并持续运行测试的简单，明确的规则，系统就会更贴近OO低耦合度，高内聚度的目标。编写测试引致更好的设计。 3. 简单设计规则2-4：重构在重构过程中，可以应用有关优秀软件设计的一切知识。提升内聚性，降低耦合度，切分关注面，模块化系统性关注面，缩小函数和类的尺寸，选用更好的名称，如此等等。这也是简单设计原则后三条规则的地方:消除重复，保证表达力，尽可能减少类和方法的数量。 4. 不可重复5. 表达力6. 尽可能少的类和方法十二、第十三章 并发编程1. 为什么要并发并发是一种解耦策略。它帮我们把做什么和何时做分解开。 2. 并发的防御原则13.1 单一权责原则（SRP）并发代码应该从其他代码中分离出来，因为，并发代码相比于其他的代码是很复杂的存在。但是，并发实现细节常常直接嵌入到其他生产代码中。那么下面几个问题需要考虑， 并发相关代码由自己的开发，修改和调优生命周期 开发相关代码由自己要对付的挑战，和非并发相关代码不同，而且往往更为困难 即便没有周边应用程序增加负担，写得不好的并发代码可能的出错方式数量已经足具挑战性。 建议：分离并发相关代码与其他代码。 13.2 限制数据作用域两个线程修改共享对象的同一字段时，可能相互干扰，导致未预期的行为。解决方案之一是采用synchronized关键字在代码中保护一块使用共享对象的临界区。限制临界区的数量很重要。更新共享数据的地方越多，就越可能出错。 建议：谨记数据封装，严格限制对可能被共享的数据的访问。 13.3 使用数据副本避免共享数据的好方法之一就是一开始就避免共享数据。在某些情况下，有可能复制对象并以只读方式对待。在另外一种情况下，有可能复制对象，从多个线程收集所有副本的结果，并在单个线程中合并这些结果。 13.4 线程尽可能地独立让每个线程在自己的世界中存在，不与其他线程共享数据。每个线程处理一个客户端请求，从不共享的源头接纳所有请求数据，存储为本地变量。 建议：尝试将数据分解到可被独立线程操作的独立子集。 13.5 了解执行模型13.5.1 生产者－－－消费者模型一个或多个生产者线程创建某些工作，并置于缓存或队列中。一个或多个消费者线程从队列中获取并完成这些工作。生产者和消费者之间的队列是一种限定资源。 13.5.2 读者－－－作者模型当存在一个主要为读者线程提供信息源，但只偶尔被作者线程更新的共享资源，吞吐量就会是个问题。增加吞吐量，会导致线程饥饿和过时信息的积累。更新会影响吞吐量。协调读者线程，不去读作者线程正在更新的消息，这是一种辛苦的平衡工作。作者线程倾向于长期锁定许多读者线程，从而导致吞吐量问题。 挑战之处在于平衡读者线程和作者线程的需求，实现正确的操作，提供合理的吞吐量，避免线程饥饿。 13.5.3哲学家问题（故事内容不在这里描述）从哲学家问题可以反映出编写并发经常遇到的问题，死锁，活锁，吞吐量和效率降低等问题。那么学习这些基础问题的解决算法可以帮助你解决大多数的并发问题，因为大多的并发问题都是上述问题的变种。 13.6 警惕同步方法之间的依赖同步方法之间的依赖会导致并发代码中的狡猾缺陷。Java语言有synchronized概念，可以用来保护单个方法。然而，如果在同一共享类中由多个同步方法，系统就可能写得不太正确了。 建议：避免使用一个共享对象的多个方法。如果有时必须使用一个共享对象的多个方法。这种情况发生时，有３中写对代码的手段： 基于客户端的锁定－－客户端代码在调用第一个方法前锁定服务端，确保锁的范围覆盖了调用最后一个方法的代码。 基于服务端的锁定－－在服务端内创建锁定服务端的方法，调用所有方法，然后解锁。让客户端代码调用新的方法。 适配服务端－－创建执行锁定的中间层。这是一种基于服务端的锁定例子，但不修改原始服务端代码。 13.7保持同步区域微小应该尽可能少地设计临界区，如果有请尽可能减小同步区域。 13.8 编写线程需要注意的几点：(1). 将伪失败看作可能的线程问题。线程代码中的缺陷可能在一千或者一百万次执行中才会显现一次。所以，不要将系统错误归咎于偶发事件。(2). 先使非线程代码可工作。确保线程之外的代码可以工作。不要同时追踪非线程缺陷和线程缺陷。确保代码在线程之外可以工作。(3). 编写可插拔的线程代码。编写在数个环境下运行的线程代码 1.单线程与多线程在执行时不同的情况 2.线程代码与实物或测试替身互动 3.用运行速度,缓慢和有变动的测试替身执行 4.将测试配置为能运行一定数量的迭代 建议：编写可插拔的线程代码，这样就能在不同的配置环境下运行。 (4). 编写可调整的线程代码在系统运行时允许线程发生变动。允许线程依据吞吐量和使用率自我调整。 (5). 运行多余处理器数量的线程任务交换越频繁，越有可能找到错过临界区或导致死锁的代码。 (6). 在不同平台上运行(7). 调整代码并强迫错误发生十三、第14章 逐步改进代码并不是一次就能写的很干净的，需要我们不断的迭代和优化。 十四、第17章 味道与启发1. 注释(1). 不恰当的注释信息让注释传达本该更好地在源代码控制系统，问题追踪系统或任何其他记录系统中保存的信息，是不恰当的。例如，修改历史记录只会用大量过时而无趣的文本搞乱源代码文件。注释只应该描述有关代码和设计的技术性信息。 (2). 废弃的注释过时，无关或不正确的注释就是废弃的注释。 (3). 冗余注释如果注释描述的是某种充分自我描述了的东西，那么注释就是多余的。注释应该谈及代码自身没有提到的东西。 (4). 注释要写就要写最好的注释，别画蛇添足(5). 注释掉的代码，看到注释掉的代码就删。2. 环境(1). 需要多步才能实现的构建构建系统应该是单步的小操作。不应该从源代码控制系统中一小点一小点签出代码。不应该需要一系列神秘指令或环境依赖脚本来构建单个元素。不应该四出寻找额外的小jar,xml文件和其他系统所需的杂物。你应该能够用单个命令签出系统，并单个指令构建它。 (2). 需要多步才能做到测试你应该能够用单个指令就可以运行全部单元测试。能够运行全部测试是如此基础和重要，应该快速，轻易和直接了当地做到。 3. 函数 函数的参数应该少。 输出参数违反直觉。如果非要修改，那就修改函数所在对象好了。 标示参数，布尔值参数宣告函数做了不止一件事，应该消灭掉，即函数只做一件事。 永不被调用的方法应该丢弃。 4. 一般性问题(1). 如果代码需要有多种语言，那么应该尽力减少源文件中额外语言的数量和范围。 (2). 明显的行为未被实现，如果明显的行为未被实现，读者和用户就不能再依靠他们对函数名称的直觉。他们不再信任原作者，不得不阅读代码细节。 (3). 不正确的边界行为，追索每种边界条件，编写测试。 (4). 忽视安全 (5). 重复，尽可能找到并消除重复。 (6). 在错误的抽象层级上的代码，创建分离较高层级一般性概念与较低层级细节概念的抽象模型，这很重要。 (7). 基类不可多度依赖于派生类，基类应该对派生类一无所知。 (8). 信息过多，设计良好的模块有着非常小的接口，让你事半功倍。设计良好的接口并不提供许多需要依靠的函数，所以耦合度比较低。 优秀的软件开发人员学会限制类或模块中暴露的接口数量。类中的方法越少越好。函数知道的变量越少越好。类拥有的实体变量越少越好。隐藏你的数据。隐藏你的工具函数。隐藏你的常量和你的临时变量。不要创建拥有大量方法或大量实体变量的类。不要为子类创建大量受保护变量和函数。尽力保持接口紧凑。通过限制信息来控制耦合度。 (9). 死代码一定要删除。 (10). 垂直分隔，变量和函数应该在靠近被使用的地方定义。私有函数应该刚好在其首次被使用的位置下面定义。 (11). 前后不一致，从一而终即一旦选中，就小心持续遵循。如果在特定函数中用了response的变量来持有HttpServletResponse对象，则在其他用到HttpServletResponse对象的函数中也用同样的变量名。这样会让你的代码更易阅读。 (12). 混淆视听，没用的变量或者函数直接删掉，以免造成不必要的干扰。 (13). 人为耦合，不互相依赖的东西不该耦合。一般来说，人为耦合是指两个没有直接目的之间的模块的耦合。其根源是将变量，常量或函数不恰当地放在临时方便的位置。 (14). 特性依恋，类的方法只应对其所属类中的变量和函数感兴趣，不该垂青其他类中的变量和函数。当方法通过某个其他对象的访问器和修改器来操作该对象内部数据，则它就依恋于该对象所属类的范围。 (15). 选择算子参数，尽量不要把boolean作为函数参数 (16). 晦涩意图，代码要尽可能具有表达力。 (17). 位置错误的权责，我们可以采用最小惊异原则来帮助我们即代码应该放在读者自然而然期待它所在的地方。 (18). 不恰当的静态方法，对于没有机会打算让它有多态行为的函数可以作为动态函数，否则可选用静态函数。 (19). 使用解释性变量，命名要有意义。 (20). 函数名称应该表达其行为 (21). 理解算法 (22). 把逻辑依赖改为物理依赖： 1.逻辑依赖：原始数据和业务逻辑之间的依赖关系。例如：定义的常量和业务逻辑存在着依赖关系或者说被捆绑在了一起，即当业务逻辑发生变化或者存在其他可能性的时候且定义的常量无法满足导致常量需要修改。 2.物理依赖：函数方法和业务逻辑之间的依赖关系。例如：为了解决逻辑依赖的问题，我们可以通过构造一个方法将数据和业务隔离。 (23). 用多态替代if/else 或 switch/case (24). 遵循标准约定 (25). 用命名常量替代魔术数，魔术数不仅仅指的是数字，也泛指任何不能自我描述的符号。 (26). 准确，在可以用List的时候，非要把变量声明为ArrayList就过分拘束了。在代码中做决定时，确认自己足够准确。明确自己为何要这么做，如果遇到异常情况如何处理。别懒得理会决定的准确性。代码中的含糊和不准确性要么是意见不同的结果，要么源于懒惰。无论原因是什么，都要消除。 (27). 结构甚于约定，坚守结构甚于约定的设计决策。 (28). 封装条件，如果没有if或while语句的上下文，布尔逻辑就难以理解。应该把解释了条件意图的函数抽离出来。 例如： if(shouldBeDeleted(timer)) 要好于 if(timer.hasExpired() &amp;&amp; !timer.isRecurrent()) (29). 避免否定性条件，尽可能将条件表示为肯定形式。 (30). 函数只该做一件事 (31). 掩蔽时序耦合，排列函数参数，好让它们被调用的次序显而易见。 (32). 别随意，构建代码需要理由，而且理由应于代码结构相契合。 (33). 封装边界条件，把处理边界条件的代码集中到一处，不要散落于代码中。 (34). 函数应该只在一个抽象层级上，函数中的语句应该在同意抽象级上，该层级应该是函数名所示操作的下一层。 (35). 在较高层级放置可配置数据，如果你有个已知并在较高抽象层级的默认常量或配置值，不要将它埋藏到较低层级的函数中。把它作为较高层级函数调用较低层级函数时的一个参数。位于较高层级的配置性常量易于修改。它们向下贯穿应用程序。应用程序的较低层级并不拥有这些常量的值。 (36). 避免传递浏览，编写害羞代码。 (37). 不要继承常量 17.5 测试 使用覆盖率工具，覆盖率工具能汇报你测试策略中的缺口。使用测试覆盖率工具能更容易地找到不足的模块，类和函数。 别略过小测试 被忽略的测试就是对不确定事物的疑问。 测试边界条件 全面测试相近的缺陷，缺陷趋向于扎堆。 测试失败的模式有启发性。 测试覆盖率的模式有启发性，查看被或未被以通过的测试执行的代码，往往能发现失败的测试为何失败的线索。 测试应该快速。 来自：代码整洁之道内容概要]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>整洁代码</tag>
        <tag>重构</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Java编程风格指南]]></title>
    <url>%2Fblogs%2F3366701135.html</url>
    <content type="text"><![CDATA[1 前言这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则，我们才认为它符合Google的Java编程风格。 与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。 1.1 术语说明本文档中除非特殊说明，否则： 术语class可表示一个普通类、枚举类、接口或者注解。 术语comment只用来指代实现的注释(implementation comments)，我们不使用文档注释(documentation comments)一词，而是用Javadoc。 其他术语说明，将在文档中需要说明的地方单独说明。 1.2 指南说明本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。示例中的格式选择不应该被强制定为规则。 2 源文件基础2.1 文件名源文件以其最顶层的类名（其中只有一个）来命名，大小写敏感，文件扩展名为.java。 2.2 文件编码：UTF-8源文件编码格式使用UTF-8。 2.3 特殊字符2.3.1 空格字符除了换行符外，ASCII水平空白字符（0x20）是源码文件中唯一支持的空格字符。这意味着： 所有其他空白字符将被转义。 Tab字符不被用作缩进控制。 2.3.2 特殊转义字符串任何需要转义字符串表示的字符（例如：\b, \t, \n, \f, \r, \&#39;, \\等），采用这种转义字符串的方式表示，而不采用对应字符的八进制数（例如 \012）或Unicode码（例如：\u000a）表示。 2.3.3 非ASCII字符对于其余非ASCII字符，直接使用Unicode字符（例如 ∞），或者使用对应的Unicode码（例如：\u221e）转义，都是允许的。唯一需要考虑的是，何种方式更能使代码容易阅读和理解。 注意：在使用Unicode码转义，或者甚至是有时直接使用Unicode字符的时候，建议多添加一些注释说明，将对别人读懂代码很有帮助。 例子： 示例 结论 String unitAbbrev = “μs”; 赞：即使没有注释也非常清晰。 String unitAbbrev = “\u03bcs”; // “μs” 允许，但没有理由要这样做。 String unitAbbrev = “\u03bcs”; // Greek letter mu, “s” 允许，但这样做显得笨拙还容易出错。 String unitAbbrev = “\u03bcs”; 很糟：读者根本看不出这是什么。 return ‘\ufeff’ + content; // byte order mark 很好：对于非打印字符，使用转义，并在必要时写上注释。 注意：永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行，你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话) 3 源文件结构源文件按照先后顺序，由以下几部分组成： 许可证(License)或版权信息(copyright)（如果需要） package语句 import语句 class类声明（每个源码文件只能有唯一一个顶级class）。 注意：以上每个部分之间应该只有一个空行作为间隔。 3.1 许可证或版权信息如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。 3.2 package语句package语句不换行，单行长度限制(4.4节)不适用于package语句。(即package语句写在一行里) 3.3 import语句3.3.1 import不使用通配符import语句中不应该使用通配符，不管是否是静态导入。 3.3.2 import不换行import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行) 3.3.3 顺序和间距import语句可分为以下几组，按照顺序，每组由一个空行分隔： 所有的静态导入(static import)归为一组 com.google包的import归为一组 使用的第三方包的导入，每个顶级按字典顺序归为一组。例如：android, com, junit, org, sun java包归为一组 javax包归为一组 注意：同一组内的import语句之间不应用空行隔开，同一组中的import语句按字典序排列。 3.4 类声明3.4.1 只声明唯一一个顶级class每个源文件中只能有一个顶级class。 3.4.2 类成员顺序类成员的顺序对代码的易读性有很大影响，但是没有一个统一正确的标准。不同的类可能有不同的排序方式。 最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如，新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。 3.4.2.1 重载：永不分离当一个类有多个构造函数，或是多个同名方法，这些方法应该按顺序出现在一起，中间不要放进其它方法。 4 格式 术语说明：块状结构(block-­like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。 4.1 大括号4.1.1 使用大括号(即使是可选的)大括号一般用在if, else, for, do, while等语句，即使只有一条语句(或是空)，也应该把大括号写上。 4.1.2 非空语句块采用K&amp;R风格对于非空语句块，大括号遵循Kernighan和Ritchie风格 (Egyptian brackets): 左大括号前不换行 左大括号后换行 右大括号前换行 如果右大括号结束是一个语句块或者方法体、构造函数体或者有命名的类体，则需要换行。当右括号后面接else或者逗号时，不应该换行。 示例： return () -> { while (condition()) { method(); } }; return new MyClass() { @Override public void method() { if (condition()) { try { something(); } catch (ProblemException e) { recover(); } } else if (otherCondition()) { somethingElse(); } else { lastThing(); } } }; 一些例外的情况，将在4.8.1节讲枚举类型的时候讲到。 4.1.3 空语句块：使代码更简洁一个空的语句块，可以在左大括号之后直接接右大括号，中间不需要空格或换行。但是当一个由几个语句块联合组成的语句块时，则需要换行。（例如：if/else 或者try/catch/finally）. 示例： // 这是可接受的 void doNothing() {} // 这同样是可接受的 void doNothingElse() { } // 这是不可接受的：多块语句中没有简洁的空语句块 try { doSomething(); } catch (Exception e) {} 4.2块缩进：2个空格每当一个新的语句块产生，缩进就增加两个空格。当这个语句块结束时，缩进恢复到上一层级的缩进格数。缩进要求对整个语句块中的代码和注释都适用。（例子可参考之前4.1.2节中的例子）。 注意：根据实际的编程经验，2个空格缩进的代码在当前大屏的计算机上会显得十分拥挤，反而使得代码臃肿不够美观。所以，我这里建议使用4个空格来缩进，会使得更加美观，而且能侧面督促开发人员减少代码的嵌套层数。 4.3 一行一个语句每条语句结束都需要换行。 4.4 列长度限制：100Java代码的列长度限制为100个字符。 除了如下所述，任何超过此限制的行都必须跳行。这在4.5节会有详细解释。 例外： 不可能满足行长度限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考) package和import语句(见3.2节和3.3节) 注释中那些可能被剪切并粘贴到shell中的命令行 注意：当前的计算机屏幕都已经比很宽了，而且变量及方法命名都较长，100个字符的长度反而会出现很多不必要的跳行，已经不适应当今的情况了，根据实际编程经验，我这里建议使用120个字符的宽度更为合适。 4.5 换行术语说明：一般情况下，一行长代码为了避免超出列限制(100个字符)而被分为多行，我们称之为断行(line­-wrapping)。 我们并没有全面，确定性的准则来决定在每一种情况下如何断行。很多时候，对于同一段代码会有好几种有效的换断行方式。 注意: 提取方法或局部变量可以解决问题，而不不需要进行断行。 4.5.1 在何处断行断行的主要原则是：选择在更高级的语法逻辑处断行。其他一些原则如下： 当一个非赋值运算的语句断行时，在运算符号之前断行。（这与Google的C++规范和JavaScrip规范等其他规范不同）。 如果要在非赋值运算符处断行，那么在该符号前断开(比如+操作符，它将位于下一行)。以下的类运算符也可作为参考： 点操作符. 类型界限中的&amp;、||等（例如：&lt;T extends Foo &amp; Bar&gt;) 当要在一个赋值运算语句处断行时，一般在赋值符号之后断行。但是也可以在之前断行。(例如：=，它与前面的内容留在同一行)。 这条规则也适用于foreach语句中的冒号。 方法名或构造函数名与左括号留在同一行。 逗号(,)与其前面的内容留在同一行。也就是在逗号之后断行。 Lambda表达式在箭头符号(-&gt;)后断行。 示例： MyLambda&lt;String, Long, Object> lambda = (String label, Long value, Object obj) -> { ... }; Predicate&lt;String> predicate = str -> longExpressionInvolving(str); 注意：换行的主要目标是使代码更清晰易读。 4.5.2 断行的缩进：至少+4个空格自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。 当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。 第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。 4.6 空白4.6.1 垂直空白以下情况需要使用单行空行： 类成员之间需要单个空行隔开：例如：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。但也有以下两种例外情况： 两个连续字段之间的空行是可选的，根据需要使用空行来创建字段间的逻辑分组。 枚举常量之间的的空行也是可选的，根据需要使用空行来创建枚举常量间的逻辑分组。 在方法体内，根据代码的逻辑分组的需要，设置空白行作为间隔。 类的第一个成员之前或最后一个成员之后，使用空行(可选)。 本文档所介绍的其他章节的空行要求(比如3.3节：import语句)。 4.6.2 水平空白除了语法、其他规则、词语分隔、注释和javadoc外，水平的ASCII空格只在以下情况出现： 所有保留的关键字与紧接它之后的位于同一行的左大括号之间需要用空格隔开。(例如：if, for catch等) 所有保留的关键字与在它之前的右大括号之间需要空格隔开。（例如：else、catch） 在左大括号之前都需要空格隔开。只有两种例外： @SomeAnnotation({a, b}) String[][] x = foo; 所有的二元运算符和三元运算符的两边，都需要空格隔开。(例如：a + b、b = a &lt; 0 ? 0 : a) 逗号(,)、冒号(:)、分号(;)和右小括号())、Lambda箭头符号(-&gt;)之后，需要空格隔开。 //双斜线开始一行注释时，双斜线两边都应该用空格隔开。并且可使用多个空格。（可选，例如：a = 0; // 赋值为0） 变量声明时，变量类型和变量名之间需要用空格隔开。（例如：List&lt;String&gt; list） 初始化一个数组时，花括号之间可以用空格隔开，也可以不使用。（可选，例如：new int[] {5, 6}和new int[] { 5, 6 }） 注意：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。 4.6.3 水平对齐：不做要求 术语说明：水平对齐，是指通过添加多个空格，使本行的某一符号与上一行的某一符号上下对齐。 这种对齐是被允许的，但是不会做强制要求。 以下是没有水平对齐和水平对齐的例子： private int x; // 这种挺好 private Color color; // 同上 private int x; // 允许，但是未来会继续编辑 private Color color; // 可能会使它对不齐 注意：水平对齐能够增加代码的可读性，但是增加了未来维护代码的难度。考虑到维护时只需要改变一行代码，之前的对齐可以不需要改动。为了对齐，你更有可能改了一行代码，同时需要更改附近的好几行代码，而这几行代码的改动，可能又会引起一些为了保持对齐的代码改动。那原本这行改动，我们称之为爆炸半径。这种改动，在最坏的情况下可能会导致大量的无意义的工作，即使在最好的情况下，也会影响版本历史信息，减慢代码review的速度，引起更多merge代码冲突的情况。 4.7 分组小括号：推荐使用除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。我们没有理由假设读者能记住整个Java运算符优先级表。 4.8 特殊结构4.8.1 枚举类型枚举常量间用逗号隔开，换行是可选的。而且还允许附加的空行（通常只有一个）。以下就是一种可能性的示例： private enum Answer { YES { @Override public String toString() { return "yes"; } }, NO, MAYBE } 没有方法和Javadoc的枚举类可写成数组初始化的格式： private enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS } 由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。 4.8.2 变量声明4.8.2.1 每次声明一个变量不要使用组合声明。例如：int a, b;是不允许的。 4.8.2.2 需要时才声明，尽快进行初始化不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。 4.8.3 数组4.8.3.1 数组初始化：可写成块状结构数组初始化可以写成块状结构，例如以下格式的写法都是允许的： new int[] { new int[] { 0, 1, 2, 3 0, } 1, 2, new int[] { 3, 0, 1, } 2, 3 } new int[] {0, 1, 2, 3} 4.8.3.2 非C风格的数组声明中括号是类型的一部分：String[] args， 而非String args[]。 4.8.4 switch语句术语说明：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(case FOO:或default:)，后面跟着一条或多条语句。 4.8.4.1 缩进和其他语句块一样，switch大括号之后缩进两个字符。每个switch标签之后，后面紧接的非标签的新行，按照大括号相同的处理方式缩进两个字符。在标签结束后，恢复到之前的缩进，类似大括号结束。 4.8.4.2 继续向下执行的注释在一个switch块内，每个语句组要么通过break、continue、return或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组，任何能表达这个意思的注释都是可以的(典型的是用// fall through)。这个特殊的注释并不需要在最后一个语句组(一般是default)中出现。例如： switch (input) { case 1: case 2: prepareOneOrTwo(); // fall through case 3: handleOneTwoOrThree(); break; default: handleLargeNumber(input); } 注意：在case 1之后不需要该注释，仅在语句组的末尾。 4.8.4.3 default标签需要显式声明每个switch语句中，都需要显式声明default标签。即使没有任何代码也需要显示声明。 注意：枚举类型的switch语句可以省略default语句组，如果它包含覆盖该类型的所有可能值的显式情况。这使得IDE或其他静态分析工具能够在丢失任何情况时发出警告。 4.8.5 注解注解应用到类、方法或者构造方法时，应紧接Javadoc之后。每一行只有一个注解。注解所在行不受列长度限制，也不需要增加缩进。例如： @Override @Nullable public String getNameIfPresent() { ... } 例外：如果注解只有一个，并且不带参数。则它可以和类或方法名放在同一行。例如： @Override public int hashCode() { ... } 注解应用到成员变量时，也是紧接Javadoc之后。不同的是，多个注解可以放在同一行。例如： @Partial @Mock DataLoader loader; 对于参数或者局部变量使用注解的情况，没有特定的规范。 4.8.6 注释4.8.6.1 块注释风格注释的缩进与它所注释的代码缩进相同。可以采用/* */进行注释，也可以用//进行注释。当使用/* */进行多行注释时，每一行都应该以*开始，并且*应该上下对齐。 例如： /* * This is * okay. */ // And so // is this. /* Or you can * even do this. */ 注意：多行注释时，如果你希望集成开发环境能自动对齐注释，你应该使用/* */，//一般不会自动对齐。 4.8.7 修饰符类和成员变量的修饰符，按Java Lauguage Specification中介绍的先后顺序排序。具体是： public protected private abstract default static final transient volatile synchronized native strictfp 4.8.8 数字字面量长整型的数字字面量使用大写的L作为后缀，不得使用小写（以免与数字1混淆）。例如：使用3000000000L，而不是3000000000l。 5 命名约定5.1 对所有标识符都通用的规则标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式\w+。 在Google其它编程语言风格中使用的特殊前缀或后缀，如name_, mName, s_name和kName，在Java编程风格中都不再使用。 5.2 标识符类型的规则5.2.1 包名包名全部小写，连续的单词只是简单地连接起来，不使用下划线。例如：使用com.example.deepspace，而不是com.example.deepSpace或者com.example.deep_space。 5.2.2 类名类名都以UpperCamelCase风格编写。 类名通常是名词或名词短语。例如：Character或者ImmutableList。接口名称也可以是名词或名词短语（例如：List），但有时可能是形容词或形容词短语（例如：Readable）。现在还没有特定的规则或行之有效的约定来命名注解类型。 测试类的命名以它要测试的类的名称开始，以Test结束。例如：HashTest或HashIntegrationTest。 5.2.3 方法名方法名都以lowerCamelCase风格编写。 方法名通常是动词或动词短语。例如：sendMessage或者stop。 下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：test&lt;MethodUnderTest&gt;_&lt;state&gt;，例如：testPop_emptyStack。 并不存在唯一正确的方式来命名测试方法。 5.2.4 常量名常量名命名模式为CONSTANT_CASE，全部字母大写，用下划线分隔单词。那到底什么算是一个常量呢？ 每个常量都是一个静态final字段，其内容是不可变的，且没有可检测的副作用。这包括原始类型、字符串、不可变类型和不可变类型的不可变集合。如果任何一个实例的观测状态是可变的，则它肯定不会是一个常量。只是永远不打算改变对象也是不够的。例如： // 常量 static final int NUMBER = 5; static final ImmutableList&lt;String> NAMES = ImmutableList.of("Ed", "Ann"); static final ImmutableMap&lt;String, Integer> AGES = ImmutableMap.of("Ed", 35, "Ann", 32); static final Joiner COMMA_JOINER = Joiner.on(','); // 因为Joiner是不可变的 static final SomeMutableType[] EMPTY_ARRAY = {}; enum SomeEnum { ENUM_CONSTANT } // 非常量 static String nonFinal = "non-final"; final String nonStatic = "non-static"; static final Set&lt;String> mutableCollection = new HashSet&lt;String>(); static final ImmutableSet&lt;SomeMutableType> mutableElements = ImmutableSet.of(mutable); static final ImmutableMap&lt;String, SomeMutableType> mutableValues = ImmutableMap.of("Ed", mutableInstance, "Ann", mutableInstance2); static final Logger logger = Logger.getLogger(MyClass.getName()); static final String[] nonEmptyArray = {"these", "can", "change"}; 这些常量的名字通常是名词或名词短语。 5.2.5 非常量字段名非常量字段名以lowerCamelCase风格编写。 这些名字通常是名词或名词短语。例如：computedValues或者index。 5.2.6 参数名参数名以lowerCamelCase风格编写。 参数应该避免用单个字符命名。 5.2.7 局部变量名局部变量名以lowerCamelCase风格编写。 即使局部变量是final和不可改变的，也不应该把它示为常量，当然也就不能用常量的规则去命名它。 5.2.8 类型变量名类型变量可用以下两种风格之一进行命名： 单个的大写字母，后面可以视具体情况跟一个数字(如：E, T, X, T2)。 以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。 5.3 驼峰式命名法(CamelCase)驼峰式命名法分大驼峰式命名法(UpperCamelCase)和小驼峰式命名法(lowerCamelCase)。有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如：IPv6或iOS)。Google指定了以下的转换方案。 名字从散文形式(prose form)开始: 把短语转换为纯ASCII码，并且移除任何单引号。例如：Müller’s algorithm将变成Muellers algorithm。 把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。 推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如AdWords将分割成ad words)。 需要注意的是iOS并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。 现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写： 每个单词的第一个字母都大写，来得到大驼峰式命名。 除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。 最后将所有的单词连接起来得到一个标识符。 示例： 散文形式 正确 不正确 “XML HTTP request” XmlHttpRequest XMLHTTPRequest “new customer ID” newCustomerId newCustomerID “inner stopwatch” innerStopwatch innerStopWatch “supports IPv6 on iOS?” supportsIpv6OnIos supportsIPv6OnIOS “YouTube importer” YouTubeImporter YoutubeImporter^ 无 加^号处表示可以，但不推荐。 注意：在英语中，某些带有连字符的单词形式不唯一。例如：nonempty和non-empty都是正确的，因此方法名checkNonempty和checkNonEmpty也都是正确的。 6 编程实践6.1 @Override：总是使用只要是合法的方法，就把@Override注解加上。这包括覆盖超类方法的类方法，实现接口方法的类方法。 例外：当父方法为@Deprecated时，可以省略@Override。 6.2 捕获的异常：不能忽视除了下面的例子，对捕获的异常不做任何响应是极少的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个AssertionError重新抛出。) 如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。 try { int i = Integer.parseInt(response); return handleNumericResponse(i); } catch (NumberFormatException ok) { // 它不是一个数字，不过没关系，继续 } return handleTextResponse(response); 例外：在测试中，如果一个捕获的异常被命名为expected，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。 try { emptyStack.pop(); fail(); } catch (NoSuchElementException expected) { } 6.3 静态成员：使用类来调用 使用类名调用静态的类成员，而不是具体某个对象或表达式。 Foo aFoo = ...; Foo.aStaticMethod(); // 好 aFoo.aStaticMethod(); // 糟 somethingThatYieldsAFoo().aStaticMethod(); // 很糟 6.4 Finalizers: 禁用 极少会去重载Object.finalize。 注意：不要使用finalize。如果你非要使用它，请先仔细阅读和理解Effective Java第7条款：“Avoid Finalizers”，然后不要使用它。 7 Javadoc7.1 格式7.1.1 一般形式Javadoc块的基本格式如下所示： /** * Multiple lines of Javadoc text are written here, * wrapped normally... */ public int method(String p1) { ... } 或者是以下单行形式： /** An especially short bit of Javadoc. */ 基本格式总是可以接受的。当整个Javadoc块能容纳于一行时(且没有标记@XXX)，就可以使用单行形式。 7.1.2 段落空行(只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签&lt;p&gt;，并且它和第一个单词间没有空格。 7.1.3 Javadoc标记标准的Javadoc标记按以下顺序出现：@param, @return, @throws, @deprecated, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格(注：如果你的缩进统一采用采用4个空格，那么这里就应该是8个空格)。 7.2 摘要片段每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。 这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以A {@code Foo} is a...或者This method returns...开头, 它也不会是一个完整的祈使句，如Save the record.。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。 注意：一个常见的错误是把简单的Javadoc写成/** @return the customer ID */，这是不正确的。它应该写成/** Returns the customer ID. */。 7.3 在哪里使用Javadoc至少在每个public类及它的每个public和protected成员处使用Javadoc，以下是一些例外： 7.3.1 例外：不言自明的方法对于简单明显的方法如getFoo，Javadoc是可选的(可以不写)。这种情况下除了写Returns the foo，确实也没有什么值得写了。 单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。 注意：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名getCanonicalName，就不应该忽视文档说明，因为读者很可能不知道词语canonical name指的是什么。 7.3.2 例外：重载如果一个方法重载了超类中的方法，那么Javadoc并非必需的。 7.3.3 可选的Javadoc对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成Javadoc，这样更统一更友好。 原文地址: Google Java Style Guide]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 常用命令]]></title>
    <url>%2Fblogs%2F2172419459.html</url>
    <content type="text"><![CDATA[Linux连接工具在项目开发过程中，所用到的服务器基本上都是linux服务器，所以掌握一些linux命令是十分必要的。推荐两款很好用的工具： Xshell：Linux命令控制台。 Xftp：最主要的是上传下载，我还可以用他来创建文件夹，创建文件，修改文件，删除文件等等。。 下面是linux的基本结构目录： ##Linux常用 ls命令就是list的缩写，通过ls 命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。。常用参数搭配： ls -a 列出目录所有文件，包含以.开始的隐藏文件 ls -A 列出除.及..的其它文件 ls -r 反序排列 ls -t 以文件修改时间排序 ls -S 以文件大小排序 ls -h 以易读大小显示 ls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来实例： ls -lhrt 按易读方式按时间反序排序，并显示文件详细信息 ls -lrS 按大小反序显示文件详细信息 ls -l t* 列出当前目录中所有以“t”开头的目录的详细内容 ls | sed &quot;s:^:pwd/:&quot; 列出文件绝对路径（不包含隐藏文件） find $pwd -maxdepth 1 | xargs ls -ld 列出文件绝对路径（包含隐藏文件） cd命令(changeDirectory),命令语法：cd [目录名]。说明：切换当前目录至dirName cd var 切换到var目录 cd .. 切换到上一层目录 cd / 切换到系统根目录 cd ~ 切换到用户主目录 pwd命令： pwd 查看当前路径 pwd -P 查看软链接的实际路径 mkdir命令：创建文件夹 -&gt;&gt;常用参数 -m: 对新建目录设置存取权限,也可以用chmod命令设置;-p: 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那 些尚不在的目录,即一次可以建立多个目录; -&gt;&gt;实例 mkdir name 当前工作目录下创建名为name的文件夹mkdir -p /tmp/test/t1/t 在tmp目录下创建路径为test/t1/t的目录，若不存在，则创建。 这两个操作直接在xftp工具中鼠标点击也能实现。 rm命令删除一个目录中的一个或多个文件或目录，如果没有使用- r选项，则rm不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状rm [选项] 文件… rm -i *.log 删除任何.log文件，删除前逐一询问确认 rm -rf test 删除test子目录及子目录中所有档案删除,并且不用一一确认 rm -- -f* 删除以-f开头的文件 rmdir命令从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对其父目录的写权限。注意：不能删除非空目录 rmdir -p parent/child/child11 当parent子目录被删除后使它也成为空目录的话，则顺便一并删除 mv命令移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。当第二个参数为目录时，可刚多个文件以空格分隔作为第一参数，移动多个文件到参数2指定的目录中 mv test.log test1.txt 将文件test.log重命名为test1.txt mv llog1.txt log2.txt log3.txt /test3 将文件log1.txt,log2.txt,log3.txt移动到根的test3目录中 mv -i log1.txt log2.txt 将文件file1改名为file2，如果file2已经存在，则询问是否覆盖 mv * ../移动当前文件夹下的所有文件到上一级目录 cp命令将源文件复制至目标文件，或将多个源文件复制至目标目录。注意：命令行复制，如果目标文件已经存在会提示是否覆盖，而在shell脚本中，如果不加-i参数，则不会提示，而是直接覆盖！ -&gt;&gt;常用参数 -i 提示-r 复制目录及目录内所有项目-a 复制的文件与原文件时间一样 -&gt;&gt;实例 cp -ai a.txt test 复制a.txt到test目录下，保持原文件时间,如果原文件存在提示是否覆盖 cp -s a.txt link_a.txt 为a.txt建议一个链接（快捷方式） cat命令 cat主要有三大功能： 一次显示整个文件:cat filename 从键盘创建一个文件:cat &gt; filename 只能创建新文件,不能编辑已有文件. 将几个文件合并为一个文件:cat file1 file2 &gt; file -&gt;&gt;常用参数 -b 对非空输出行号-n 输出所有行号 -&gt;&gt;实例 cat -n log2012.log log2013.log 把 log2012.log 的文件内容加上行号后输入 log2013.log 这个文件里 cat -b log2012.log log2013.log log.log把 log2012.log 和 log2013.log 的文件内容加上行号（空白行不加）之后将内容附加到 log.log 里 less命令less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。 -&gt;&gt;常用命令参数 -i 忽略搜索时的大小写 -N 显示每行的行号 -o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来 -s 显示连续空行为一行 /字符串：向下搜索“字符串”的功能 ?字符串：向上搜索“字符串”的功能 n：重复前一个搜索（与 / 或 ? 有关） N：反向重复前一个搜索（与 / 或 ? 有关） -x &lt;数字&gt; 将“tab”键显示为规定的数字空格 b 向后翻一页 d 向后翻半页 h 显示帮助界面 Q 退出less 命令 u 向前滚动半页 y 向前滚动一行 空格键 滚动一行 回车键 滚动一页 [pagedown]： 向下翻动一页 [pageup]： 向上翻动一页 -&gt;&gt;实例： ps -aux | less -N ps查看进程信息并通过less分页显示 less 1.log 2.log 可以使用n查看下一个，使用p查看前一个 more命令功能类似于cat, more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示 -&gt;&gt;命令参数： +n 从笫n行开始显示 -n 定义屏幕大小为n行 +/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 -c 从顶部清屏，然后显示 -d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能 -l 忽略Ctrl+l（换页）字符 -p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似 -s 把连续的多个空行显示为一行 -u 把文件内容中的下画线去掉 -&gt;&gt;常用操作命令： Enter 向下n行，需要定义。默认为1行 Ctrl+F 向下滚动一屏 空格键 向下滚动一屏 Ctrl+B 返回上一屏 = 输出当前行的行号 :f 输出文件名和当前行的行号 V 调用vi编辑器 !命令 调用Shell，并执行命令 q 退出more -&gt;&gt;实例： more +3 text.txt 显示文件中从第3行起的内容 ls -l | more -5 在所列出文件目录详细信息，借助管道使每次显示5行，按空格显示下5行 tail命令用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。 -&gt;&gt;常用参数： -f 循环读取（常用于查看递增的日志文件） -n&lt;行数&gt; 显示行数（从后向前） -&gt;&gt;实例： tail -f ping.log 查看日志 find命令用于在文件树中查找文件，并作出相应的处理 -&gt;&gt;命令格式 find pathname -options [-print -exec -ok ...] -&gt;&gt;命令参数： pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。 -print： find命令将匹配的文件输出到标准输出。 -exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为’command’ { } \;，注意{ }和\；之间的空格。 -ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。 -&gt;&gt;命令选项： -name 按照文件名查找文件 -perm 按文件权限查找文件 -user 按文件属主查找文件 -group 按照文件所属的组来查找文件。 -type 查找某一类型的文件，诸如： b - 块设备文件 d - 目录 c - 字符设备文件 l - 符号链接文件 p - 管道文件 f - 普通文件 -size n :[c] 查找文件长度为n块文件，带有c时表文件字节大小 -amin n 查找系统中最后N分钟访问的文件 -atime n 查找系统中最后n*24小时访问的文件 -cmin n 查找系统中最后N分钟被改变文件状态的文件 -ctime n 查找系统中最后n*24小时被改变文件状态的文件 -mmin n 查找系统中最后N分钟被改变文件数据的文件 -mtime n 查找系统中最后n*24小时被改变文件数据的文件(用减号-来限定更改时间在距今n日以内的文件，而用加号+来限定更改时间在距今n日以前的文件。 ) -maxdepth n 最大查找目录深度 -prune 选项来指出需要忽略的目录。在使用-prune选项时要当心，因为如果你同时使用了-depth选项，那么-prune选项就会被find命令忽略 -newer 如果希望查找更改时间比某个文件新但比另一个文件旧的所有文件，可以使用-newer选项 -&gt;&gt;实例： find -atime -2 查找48小时内修改过的文件 find ./ -name &#39;*.log&#39; 在当前目录查找 以.log结尾的文件。 “. “代表当前目录 find /opt -perm 777 查找/opt目录下 权限为 777的文件 find -size +1000c 查找大于1K的文件 find -size 1000c 查找等于1000字符的文件 -exec 参数后面跟的是command命令，它的终止是以;为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。{} 花括号代表前面find查找出来的文件名。 -&gt;&gt;实例： find . -type f -mtime +10 -exec rm -f {} \ 在当前目录中查找更改时间在10日以前的文件并删除它们(无提醒） find . -name &#39;*.log&#39; mtime +5 -ok -exec rm {} \ 当前目录中查找所有文件名以.log结尾、更改时间在5日以上的文件，并删除它们，只不过在删除之前先给出提示。 按y键删除文件，按n键不删除 find . -f -name &#39;passwd*&#39; -exec grep &quot;pkg&quot; {} \ 当前目录下查找文件名以passwd开头，内容包含”pkg”字符的文件 find . -name &#39;*.log&#39; -exec cp {} test3 \ 用exec选项执行cp命令 -xargs find 命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，不像-exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。 -&gt;&gt;实例： find . -type f -print | xargs file查找当前目录下每个普通文件，然后使用xargs来判断文件类型 find . -type f -name &quot;*.js&quot; -exec grep -lF &#39;ueditor&#39; {} \查找当前目录下所有以js结尾的并且其中包含’editor’字符的普通文件 find -type f -name &#39;*.js&#39; | xargs grep -lF &#39;editor&#39; find . -name &quot;*.log&quot; | xargs -i mv {} test4利用xargs执行mv命令 find . -name \*(转义） -type f -print | xargs grep -n &#39;hostnames&#39;用grep命令在当前目录下的所有普通文件中搜索hostnames这个词,并标出所在行 find . -name &#39;[a-z]*[4-9].log&#39; -print查找当前目录中以一个小写字母开头，最后是4到9加上.log结束的文件 find test -path &#39;test/test4&#39; -prune -o -print在test目录查找不在test4子目录查找 find -newer log2012.log ! -newer log2017.log实例1：查找更改时间比文件log2012.log新但比文件log2017.log旧的文件 使用depth选项：depth选项可以使find命令向磁带上备份文件系统时，希望首先备份所有的文件，其次再备份子目录中的文件。 -&gt;&gt;实例： find / -name &quot;CON.FILE&quot; -depth -print find命令从文件系统的根目录开始，查找一个名为CON.FILE的文件。 它将首先匹配所有的文件然后再进入子目录中查找 tar命令用来压缩和解压文件。tar本身不具有压缩功能，只具有打包功能，有关压缩及解压是调用其它的功能来完成。 弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件 -&gt;&gt;常用参数： -c 建立新的压缩文件 -f 指定压缩文件 -r 添加文件到已经压缩文件包中 -u 添加改了和现有的文件到压缩包中 -x 从压缩包中抽取文件 -t 显示压缩文件中的内容 -z 支持gzip压缩 -j 支持bzip2压缩 -Z 支持compress解压文件 -v 显示操作过程 有关gzip及bzip2压缩 gzip实例： gzip fileName .tar.gz 压缩 gunzip filename.gz或gzip -d filename.gz 解压 对应： tar zcvf filename.tar.gz 压缩 tar zxvf filename.tar.gz 解压 bz2实例： bzip2 -z filename .tar.bz2 压缩 bunzip filename.bz2或bzip -d filename.bz2 解压 对应： tar jcvf filename.tar.gz 压缩 tar jxvf filename.tar.bz2 解压： -&gt;&gt;实例： tar -cvf log.tar 1.log,2.log 或tar -cvf log.* 将文件全部打包成tar包 tar -zcvf /tmp/etc.tar.gz /etc 将/etc下的所有文件及目录打包到指定目录，并使用gz压缩 tar -ztvf /tmp/etc.tar.gz 查看刚打包的文件内容（一定加z，因为是使用gzip压缩的） tar --exclude /home/dmtsai -zcvf myfile.tar.gz /home/* /etc 要压缩打包/home, /etc ，但不要 /home/dmtsai grep命令强大的文本搜索命令，grep(Global Regular Expression Print)全局正则表达式搜索 grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。 -&gt;&gt;命令格式 grep [option] pattern file|dir -&gt;&gt;常用参数： -A n --after-context 显示匹配字符后n行 -B n --before-context 显示匹配字符前n行 -C n --context 显示匹配字符前后n行 -c --count 计算符合样式的列数 -i 忽略大小写 -l 只列出文件内容符合指定的样式的文件名称 -f 从文件中读取关键词 -n 显示匹配内容的所在文件中行数 -R 递归查找文件夹 grep的规则表达式: ^ 锚定行的开始 如：’^grep’匹配所有以grep开头的行。$ 锚定行的结束 如：’grep$’匹配所有以grep结尾的行。. 匹配一个非换行符的字符 如：’gr.p’匹配gr后接一个任意字符，然后是p。* 匹配零个或多个先前字符 如：’grep’匹配所有一个或多个空格后紧跟grep的行。`.一起用代表任意字符。[]匹配一个指定范围内的字符，如&#39;[Gg]rep&#39;匹配Grep和grep。[^]匹配一个不在指定范围内的字符，如：&#39;[^A-FH-Z]rep&#39;匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。(..)标记匹配字符，如&#39;\(love\)&#39;，love被标记为1。\&lt;锚定单词的开始，如:&#39;\&lt;grep&#39;匹配包含以grep开头的单词的行。>锚定单词的结束，如&#39;grep\&gt;&#39;匹配包含以grep结尾的单词的行。x{m}重复字符x，m次，如：&#39;0\{5\}&#39;匹配包含5个o的行。x{m,}重复字符x,至少m次，如：&#39;o\{5,\}&#39;匹配至少有5个o的行。x{m,n}重复字符x，至少m次，不多于n次，如：&#39;o\{5,10\}&#39;匹配5--10个o的行。\w匹配文字和数字字符，也就是[A-Za-z0-9]，如：&#39;G\w*p&#39;匹配以G后跟零个或多个文字或数字字符，然后是p。\W\w的反置形式，匹配一个或多个非单词字符，如点号句号等。\b` 单词锁定符，如: ‘\bgrep\b’只匹配grep。 -&gt;&gt;实例： ps -ef | grep svn 查找指定进程 ps -ef | grep svn -c 查找指定进程个数 cat test1.txt | grep -f key.log 从文件中读取关键词 grep -lR &#39;^grep&#39; /tmp 从文件夹中递归查找以grep开头的行，并只列出文件 grep &#39;^[^x]&#39; test.txt 查找非x开关的行内容 grep -E &#39;ed|at&#39; test.txt 显示包含ed或者at字符的内容行 ps命令ps(process status)，用来查看当前运行的进程状态，一次性查看，如果需要动态连续结果使用top linux上进程有5种状态: 运行(正在运行或在运行队列中等待) 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号) 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放) 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行) ps工具标识进程的5种状态码: D 不可中断 uninterruptible sleep (usually IO)R 运行 runnable (on run queue)S 中断 sleepingT 停止 traced or stoppedZ 僵死 a defunct (”zombie”) process -&gt;&gt;命令参数： -A 显示所有进程 a 显示所有进程 -a 显示同一终端下所有进程 c 显示进程真实名称 e 显示环境变量 f 显示进程间的关系 r 显示当前终端运行的进程 -aux 显示所有包含其它使用的进程 -&gt;&gt;实例： ps -ef 显示当前所有进程环境变量及进程间关系 ps -A 显示当前所有进程 ps -aux | grep apache 与grep联用查找某进程 ps aux | grep &#39;(cron|syslog)&#39; 找出与 cron 与 syslog 这两个服务有关的 PID 号码 kill命令发送指定的信号到相应进程。不指定型号将发送SIGTERM（15）终止指定进程。如果任无法终止该程序可用“-KILL” 参数，其发送的信号为SIGKILL(9) ，将强制结束进程，使用ps命令或者jobs 命令可以查看进程号。root用户将影响用户的进程，非root用户只能影响自己的进程。 -&gt;&gt;常用参数： -l 信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称 -a 当处理当前进程时，不限制命令名和进程号的对应关系 -p 指定kill 命令只打印相关进程的进程号，而不发送任何信号 -s 指定发送信号 -u 指定用户 -&gt;&gt;实例： kill -9 $(ps -ef | grep pro1) 先使用ps查找进程pro1，然后用kill杀掉 其他命令head命令head 用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。 -&gt;&gt;常用参数： -n&lt;行数&gt; 显示的行数（行数为复数表示从最后向前数） -&gt;&gt;实例： head 1.log -n 20 显示1.log文件中前20行 head -c 20 log2014.log 显示1.log文件前20字节 head -n -10 t.log显示t.log最后10行 which命令 在linux要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索： which 查看可执行文件的位置。 whereis 查看文件的位置。 locate 配合数据库查看文件位置。 find 实际搜寻硬盘查询文件名称。 which是在PATH就是指定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果。使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。 -&gt;&gt;常用参数： -n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。 -&gt;&gt;实例： which ls 查看ls命令是否存在，执行哪个 which which 查看which which cd查看cd（显示不存在，因为cd是内建命令，而which查找显示是PATH中的命令）查看当前PATH配置：echo $PATH；或使用env查看所有环境变量及对应值 whereis命令whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。whereis及locate都是基于系统内建的数据库进行搜索，因此效率很高，而find则是遍历硬盘查找文件。 -&gt;&gt;常用参数： -b 定位可执行文件。 -m 定位帮助文件。 -s 定位源代码文件。 -u 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。 -&gt;&gt;实例： whereis locate 查找locate程序相关文件 whereis -s locate 查找locate的源码文件 whereis -m locate 查找lcoate的帮助文件 locate命令locate通过搜寻系统内建文档数据库达到快速找到档案，数据库由updatedb程序来更新，updatedb是由cron daemon周期性调用的。默认情况下locate命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是locate所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb每天会跑一次，可以由修改crontab来更新设定值。(etc/crontab)。 locate与find命令相似，可以使用如*、?等进行正则匹配查找 -&gt;&gt;常用参数： -l num（要显示的行数） -f 将特定的档案系统排除在外，如将proc排除在外 -r 使用正则运算式做为寻找条件 -&gt;&gt;实例： locate pwd查找和pwd相关的所有文件(文件名中包含pwd） locate /etc/sh 搜索etc目录下所有以sh开头的文件 locate -r &#39;^/var.*reason$&#39;（其中.表示一个字符，表示任务多个；.表示任意多个字符） 查找/var目录下，以reason结尾的文件 chmod命令用于改变linux系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。 每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。可使用ls -l test.txt查找 以文件log2012.log为例： -rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log 第一列共有10个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是d，表示是一个目录。从第二个字符开始到第十个共9个字符，3个字符一组，分别表示了3组用户对文件或者目录的权限。权限字符用横线代表空许可，r代表只读，w代表写，x代表可执行。 -&gt;&gt;常用参数： -c 当发生改变时，报告处理信息 -R 处理指定目录以及其子目录下所有文件 权限范围： u ：目录或者文件的当前的用户 g ：目录或者文件的当前的群组 o ：除了目录或者文件的当前用户或群组之外的用户或者群组 a ：所有的用户及群组 权限代号： r ：读权限，用数字4表示 w ：写权限，用数字2表示 x ：执行权限，用数字1表示 ：删除权限，用数字0表示 s ：特殊权限 -&gt;&gt;实例： chmod a+x t.log 增加文件t.log所有用户可执行权限 chmod u=r t.log -c撤销原来所有的权限，然后使拥有者具有可读权限,并输出处理信息 chmod 751 t.log -c（或者：chmod u=rwx,g=rx,o=x t.log -c) 给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限 chmod u+r,g+r,o+r -R text/ -c 将test目录及其子目录所有文件添加可读权限 chown命令chown将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符 -&gt;&gt;常用参数： -c 显示更改的部分的信息 -R 处理指定目录及子目录 -&gt;&gt;实例： chown -c mail:mail log2012.log 改变拥有者和群组 并显示改变信息 chown -c :mail t.log 改变文件群组 chown -cR mail: test/ 改变文件夹及子文件目录属主及属组为mail df命令 显示磁盘空间使用情况。获取硬盘被占用了多少空间，目前还剩下多少空间等信息，如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示。默认情况下，磁盘空间将以 1KB 为单位进行显示，除非环境变量 POSIXLY_CORRECT 被指定，那样将以512字节为单位进行显示 -&gt;&gt;常用参数： -a 全部文件系统列表 -h 以方便阅读的方式显示信息 -i 显示inode信息 -k 区块为1024字节 -l 只显示本地磁盘 -T 列出文件系统类型 实例： df -l 显示磁盘使用情况 df -haT 以易读方式列出所有文件系统及其类型 du命令du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看 -&gt;&gt;命令格式 du [选项] [文件] -&gt;&gt;常用参数： -a 显示目录中所有文件大小 -k 以KB为单位显示文件大小 -m 以MB为单位显示文件大小 -g 以GB为单位显示文件大小 -h 以易读方式显示文件大小 -s 仅显示总计 -c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和 -&gt;&gt;实例： du -h scf/ 以易读方式显示文件夹内及子文件夹大小 du -ah scf/ 以易读方式显示文件夹内所有文件大小 du -hc test/ scf/ 显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和 du -hc --max-depth=1 scf/ 输出当前目录下各个子目录所使用的空间 ln命令功能是为文件在另外一个位置建立一个同步的链接，当在不同目录需要该问题时，就不需要为每一个目录创建同样的文件，通过ln创建的链接（link）减少磁盘占用量。 链接分类：软件链接及硬链接 软链接： 软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式 软链接可以 跨文件系统 ，硬链接不可以 软链接可以对一个不存在的文件名进行链接 软链接可以对目录进行链接 硬链接: 硬链接，以文件副本的形式存在。但不占用实际空间。 不允许给目录创建硬链接 硬链接只有在同一个文件系统中才能创建 需要注意：第一：ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化； 第二：ln的链接又分软链接和硬链接两种，软链接就是ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。 第三：ln指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。 -&gt;&gt;常用参数： -b 删除，覆盖以前建立的链接 -s 软链接（符号链接） -v 显示详细处理过程 -&gt;&gt;实例： ln -sv source.log link.log 给文件创建软链接，并显示操作信息 ln -v source.log link1.log 给文件创建硬链接，并显示操作信息 ln -sv /opt/soft/test/test3 /opt/soft/test/test5 给目录创建软链接 date命令显示或设定系统的日期与时间 -&gt;&gt;命令参数： -d&lt;字符串&gt; 显示字符串所指的日期与时间。字符串前后必须加上双引号。 -s&lt;字符串&gt; 根据字符串来设置日期与时间。字符串前后必须加上双引号。 -u 显示GMT。 %H 小时(00-23) %I 小时(00-12) %M 分钟(以00-59来表示) %s 总秒数。起算时间为1970-01-01 00:00:00 UTC。 %S 秒(以本地的惯用法来表示) %a 星期的缩写。 %A 星期的完整名称。 %d 日期(以01-31来表示)。 %D 日期(含年月日)。 %m 月份(以01-12来表示)。 %y 年份(以00-99来表示)。 %Y 年份(以四位数来表示)。 -&gt;&gt;实例： date +%Y%m%d --date=&quot;+1 day&quot; 显示下一天 -d参数使用 date -d &quot;nov 22&quot; 今年的 11 月 22 日是星期三 date -d &#39;2 weeks&#39; 2周后的日期 date -d &#39;next monday&#39; 下周一的日期 date -d next-day +%Y%m%d 或 date -d tomorrow +%Y%m%d 明天的日期 date -d last-day +%Y%m%d 或 date -d yesterday +%Y%m%d 昨天的日期 date -d last-month +%Y%m 上个月是几月 date -d next-month +%Y%m 下个月是几月 cal命令可以用户显示公历（阳历）日历如只有一个参数，则表示年份(1-9999)，如有两个参数，则表示月份和年份 -&gt;&gt;常用参数： -3 显示前一月，当前月，后一月三个月的日历 -m 显示星期一为第一列 -j 显示在当前年第几天 -y [year]显示当前年[year]份的日历 -&gt;&gt;实例： cal 9 2012 显示指定年月日期 cal -y 2013 显示2013年每个月日历 cal -3m 将星期一做为第一列,显示前中后三月 wc命令wc(word count)功能为统计指定的文件中字节数、字数、行数，并将统计结果输出 -&gt;&gt;命令格式： wc [option] file.. -&gt;&gt;命令参数： -c 统计字节数 -l 统计行数 -m 统计字符数 -w 统计词数，一个字被定义为由空白、跳格或换行字符分隔的字符串 -&gt;&gt;实例： wc text.txt 查找文件的 行数 单词数 字节数 文件名结果：7 8 70 test.txt cat test.txt | wc -l 统计输出结果的行数 top命令显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等 常用参数： -c 显示完整的进程命令 -s 保密模式 -p &lt;进程号&gt; 指定进程显示 -n &lt;次数&gt;循环显示次数 -&gt;&gt;实例： top - 14:06:23 up 70 days, 16:44, 2 users, load average: 1.25, 1.32, 1.35 Tasks: 206 total, 1 running, 205 sleeping, 0 stopped, 0 zombie Cpu(s): 5.9%us, 3.4%sy, 0.0%ni, 90.4%id, 0.0%wa, 0.0%hi, 0.2%si, 0.0%st Mem: 32949016k total, 14411180k used, 18537836k free, 169884k buffers Swap: 32764556k total, 0k used, 32764556k free, 3612636k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 28894 root 22 0 1501m 405m 10m S 52.2 1.3 2534:16 java 前五行是当前系统情况整体的统计信息区: 第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下： 14:06:23 — 当前系统时间up 70 days, 16:44 — 系统已经运行了70天16小时44分钟（在这期间系统没有重启过的吆！）2 users — 当前有2个用户登录系统load average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。 第二行，Tasks — 任务（进程），具体信息说明如下： 系统现在共有206个进程，其中处于运行中的有1个，205个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。 第三行，cpu状态信息，具体属性说明如下： 5.9%us — 用户空间占用CPU的百分比。3.4% sy — 内核空间占用CPU的百分比。0.0% ni — 改变过优先级的进程占用CPU的百分比90.4% id — 空闲CPU百分比0.0% wa — IO等待占用CPU的百分比0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比0.2% si — 软中断（Software Interrupts）占用CPU的百分比备注：在这里CPU的使用比率和windows概念不同，需要理解linux系统用户空间和内核空间的相关知识！ 第四行,内存状态，具体信息如下： 32949016k total — 物理内存总量（32GB）14411180k used — 使用中的内存总量（14GB）18537836k free — 空闲内存总量（18GB）169884k buffers — 缓存的内存量 （169M） 第五行，swap交换分区信息，具体信息说明如下： 32764556k total — 交换区总量（32GB）0k used — 使用的交换区总量（0K）32764556k free — 空闲交换区总量（32GB）3612636k cached — 缓冲的交换区总量（3.6GB） 第六行，空行。 第七行以下：各进程（任务）的状态监控，项目列信息说明如下： PID — 进程idUSER — 进程所有者PR — 进程优先级NI — nice值。负值表示高优先级，正值表示低优先级VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RESRES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATASHR — 共享内存大小，单位kbS — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程%CPU — 上次更新到现在的CPU时间占用百分比%MEM — 进程使用的物理内存百分比TIME+ — 进程使用的CPU时间总计，单位1/100秒COMMAND — 进程名称（命令名/命令行） -&gt;&gt;top交互命令 h 显示top交互命令帮助信息 c 切换显示命令名称和完整命令行 m 以内存使用率排序 P 根据CPU使用百分比大小进行排序 T 根据时间/累计时间进行排序 W 将当前设置写入~/.toprc文件中 o 或 O 改变显示项目的顺序 free命令显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。 -&gt;&gt;命令参数： -b 以Byte显示内存使用情况 -k 以kb为单位显示内存使用情况 -m 以mb为单位显示内存使用情况 -g 以gb为单位显示内存使用情况 -s&lt;间隔秒数&gt; 持续显示内存 -t 显示内存使用总合 -&gt;&gt;实例： free|free -k|free -m 显示内存使用情况 free -t 以总和的形式显示内存的使用信息 free -s 10 周期性查询内存使用情况 后记 感谢这位大佬的整合~如若不允许转载，请联系博主删除。 后续会更新常用插件安装后的命令，比如上传(rz)下载(sz)编辑(vim)等等。 eg： yum install lrzsz：同步安装rz、sz rz：从本地上传文件至服务器 sz filename：从服务器下载文件至本地]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String字符串转Date日期]]></title>
    <url>%2Fblogs%2F451064031.html</url>
    <content type="text"><![CDATA[日期转换 今日写代码的时候，发现前端的日期格式字符串不能被后台接收。于是找出了下面这么个配置来统一处理日期格式的转换。 非BOOT方式xml配置：import java.text.SimpleDateFormat; import java.util.Date; import org.springframework.beans.propertyeditors.CustomDateEditor; import org.springframework.web.bind.WebDataBinder; import org.springframework.web.bind.annotation.InitBinder; import org.springframework.web.bind.support.WebBindingInitializer; public class CustomDateFormat implements WebBindingInitializer { /** * form表单提交 Date类型数据绑定 * @param binder * @see [类、类#方法、类#成员] */ @InitBinder public void initBinder(WebDataBinder binder) { SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); dateFormat.setLenient(false); binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, true)); } } 并在spingMVC配置文件进行配置 &lt;bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"> &lt;property name="webBindingInitializer"> &lt;bean class="com.spinach.core.web.CustomDateFormat"/> &lt;/property> &lt;/bean> 自定义DateConverterConfig重写convert方法实现spring提供的Converter，重写里面的convert方法：： import lombok.extern.slf4j.Slf4j; import org.springframework.core.convert.converter.Converter; import org.springframework.stereotype.Component; import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Date; import java.util.List; @Component @Slf4j public class DateConverterConfig implements Converter&lt;String, Date> { private static final List&lt;String> FORMARTS = new ArrayList&lt;>(4); static { FORMARTS.add("yyyy-MM"); FORMARTS.add("yyyy-MM-dd"); FORMARTS.add("yyyy-MM-dd HH:mm"); FORMARTS.add("yyyy-MM-dd HH:mm:ss"); } @Override public Date convert(String source) { String value = source.trim(); if ("".equals(value)) { return null; } if (source.matches("^\\d{4}-\\d{1,2}$")) { return parseDate(source, FORMARTS.get(0)); } else if (source.matches("^\\d{4}-\\d{1,2}-\\d{1,2}$")) { return parseDate(source, FORMARTS.get(1)); } else if (source.matches("^\\d{4}-\\d{1,2}-\\d{1,2} {1}\\d{1,2}:\\d{1,2}$")) { return parseDate(source, FORMARTS.get(2)); } else if (source.matches("^\\d{4}-\\d{1,2}-\\d{1,2} {1}\\d{1,2}:\\d{1,2}:\\d{1,2}$")) { return parseDate(source, FORMARTS.get(3)); } else { throw new IllegalArgumentException("Invalid boolean value '" + source + "'"); } } /** * 格式化日期 * * @param dateStr String 字符型日期 * @param format String 格式 * @return Date 日期 */ private Date parseDate(String dateStr, String format) { Date date = null; try { DateFormat dateFormat = new SimpleDateFormat(format); date = dateFormat.parse(dateStr); } catch (Exception e) { log.error("日期转换错误", e); } return date; } } 我这里是springboot项目通过@Component注解将这个类交给spring容器托管的，如果springmvc项目还需要到xml配置文件注册这个类优点很明显了：足够灵活，在静态代码块里自定义任意格式日期，在重写的方法里在配上对应的正则表达式就行，也可以做到全局统一处理。 后记 感谢这位博主的文章，若有侵权，请联系博主删除。点击去原文]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用阿里云搭配git搭建博客]]></title>
    <url>%2Fblogs%2F166738594.html</url>
    <content type="text"><![CDATA[近期在阿里云买了个学生服务器，就想着把github上的博客迁移过来。整个过程陆陆续续花了一个多星期的时间，也踩了不少坑，在此做个记录备忘。 准备工作开启端口，轻量级服务器不用手动开，默认带了三个。ECS服务器需要自己配置。开启端口如下： 1、安装git使用yum安装即可 yum install git 完成后输入git version,若显示git版本信息即安装成功。 2、安装Node.js 去官网下载https://nodejs.org/en/download/，博主是用的最新版10.15.3，请务必使用7以上的版本，不然使用hexo时会报错。 解压缩改名放到/usr/local tar xvJf node-v10.15.3-linux-x64.tar.xz 将解压的 Node.js 目录移动到 /usr/local 目录下 mv node-v10.15.3-linux-x64 /usr/local/node-v10 软链接到 /bin 目录 ln -s /usr/local/node-v10/bin/node /bin/node ln -s /usr/local/node-v10/bin/npm /bin/npm 配置环境变量将 /usr/local/node-v6/bin 目录添加到 $PATH 环境变量中可以方便地使用通过 npm 全局安装的第三方工具 echo 'export PATH=/usr/local/node-v10/bin:$PATH' >> /etc/profile 使环境变量生效 source /etc/profile 测试是否成功输入node -v和npm -v,若显示版本号，即安装成功。 3、安装Hexo 安装Hexo执行以下命令即安装Hexo： npm install -g hexo-cli 安装完成后输入hexo version，若显示版本信息则安装成功。 具体hexo教程请自行百度，百度上有详细介绍(后续再补)。 4、安装Nginx 使用 yum 来安装 Nginx yum install nginx 启动Nginx systemctl start nginx 此时访问http//(你的ip地址),看到nginx测试界面则表示启动成功。 继续输入以下命令使Nginx开机自动启动： systemctl enable nginx 配置静态服务器访问路径Nginx 需要配置静态资源的路径信息才能通过 url 正确访问到服务器上的静态资源。即是要将HEXO生成的静态资源的路径放置到Nginx的访问路径 打开 Nginx 的默认配置文件 /etc/nginx/nginx.conf ，将默认的 root /usr/share/nginx/html 修改为: root /…//public （此处可能在此配置文件的42行，即为hexo初始化的文件夹） 修改完成后保存，输入以下命令重启Nginx： nginx -s reload 此时再次访问你的IP地址，若显示上文的hexo初次运行的样子，则说明配置成功。 注意：可能会报403错误，原因是nginx没有权限访问public文件夹，修改方法有两种：1.修改public文件夹的权限，修改为777（即任何人可读可写可执行），不推荐2. 修改nginx.conf中的user（可能在第5行），改为可以访问public文件夹的用户，如root。 5、创建git环境 在云服务器上创建一个 GIT 用户，用来运行 GIT 服务 创建用户：adduser git 设置密码：passwd git 创建证书 切换到git用户：su git 创建.ssh目录：mkdir .ssh &amp;&amp; chmod 700 .ssh 然后在云服务创建authorized_keys公钥保存文件：touch .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys tip:公钥保存文件authorized_keys是一行添加一个 创建git仓库目录创建一个名为blog的git仓库 mkdir /var/repo cd /var/repo git init --bare blog.git 配置 GIT HOOKS(钩子) vim /var/repo/blog.git/hooks/post-receive 添加以下内容，wq保存。 #!/bin/sh git --work-tree=/var/www/hexo --git-dir=/var/repo/blog.git checkout -f 设置权限 chmod +x /var/repo/blog.git/hooks/post-receive 改变 blog.git 目录的拥有者为 git 用户 chown -R git:git blog.git 创建静态文件目录并将3步骤生成的git仓库链接到静态文件目录下 创建静态文件目录（文章网页）：mkdir /var/www/hexo 链接git仓库：chown -R git:git /var/www/hexo 配置权限：chmod -R 755 /var/www/hexo 这样git仓库更新便会自动同步到hexo目录下 禁用shell登录输入以下指令vim /etc/passwd找到下面这行： git:x:1001:1001:,,,:/home/git:/bin/bash 改为： git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。 测试当上述步骤都完成后，我们就可以测试下git服务器是否部署成功，最简单的方法便是使用clone来校验。在用户git控制台输入git clone git@服务器ip:/var/repo/blog.git，当弹出密码输入框即环境搭建成功。 6、后续 剩下的操作与使用git操作无异，提交代码至git服务器，git代码会自动推送至public目录，然后通过nginx代理即可访问自己的博客啦~ 点击 参考原文1 点击 参考原文2 感谢以上两位博主的博客，没有他们的前置我也搭不出来现在的博客。若有侵权，请联系博主删除。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 多级菜单树工具]]></title>
    <url>%2Fblogs%2F1705435210.html</url>
    <content type="text"><![CDATA[关于Java中多级菜单树的处理 今天被一个菜单列表的展现折磨得不轻，自己写代码发现实在是费时费力，而且代码量太大，逻辑亟待优化，后续找到了这个代码十分简洁的工具类，说实话我只能看得懂，写不出来这种东西。在此分享给大家，避免重复造轮子的工作~ 多级树Bean这是一个基础bean： /** * 功能描述： * 【分组信息bean】 * 注意，下面的bean每个属性都为必要属性，不可缺一 * 可以在此bean基础上再添加多个属性，不会影响树结构 * 类上的三个注解为lombok插件 * * @author chihiro * @version V1.0 * @date 2019/03/06 17:35 */ @Data @NoArgsConstructor @AllArgsConstructor public class GroupInfoBean { /** * 分组主键 */ private String groupId; /** * 父节点id */ private String parentId; /** * 子节点集合 */ private List&lt;GroupInfoVo> children; } 树工具类核心工具类： /** * 功能描述： * 【多级树util】 * 核心是使用递归 * * @author chihiro * @version V1.0 * @date 2019/03/06 18:45 */ @AllArgsConstructor public class TreeToolUtil { /** * 根节点 */ private List&lt;GroupInfoVo> rootList; /** * 叶子节点，可包含跟节点 */ private List&lt;GroupInfoVo> bodyList; public List&lt;GroupInfoVo> getTree() { if (CollUtil.isNotEmpty(bodyList)) { //声明一个map，用来过滤已操作过的数据 Map&lt;String, String> map = MapUtil.newHashMap(bodyList.size()); rootList.forEach(beanTree -> getChild(beanTree, map)); return rootList; } return null; } private void getChild(GroupInfoVo beanTree, Map&lt;String, String> map) { List&lt;GroupInfoVo> childList = CollUtil.newArrayList(); bodyList.stream() .filter(group -> !map.containsKey(group.getGroupId())) .filter(group -> group.getParentId().equals(beanTree.getGroupId())) .forEach(group -> { map.put(group.getGroupId(), group.getParentId()); getChild(group, map); childList.add(group); }); beanTree.setChildren(childList); } } 后记 这套代码也是本人从网上找来调整为自己使用的，非本人自主构建。 若遇到其他Bug，请通过博客内联系方式找到我，我尽量解决。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客说明]]></title>
    <url>%2Fblogs%2F1523215152.html</url>
    <content type="text"><![CDATA[重点说明 本站主页背景，个人相册，以及部分文章的展示图皆为wlop大大所绘制的插画，这些插画为本人所购得，如若有侵权，请联系博主删除(ps：这些画都是被我压缩过的，没有原版图，即使下载了也当不了背景或桌面)。若想取得高清/超清插画，请去友情链接中支持原作者 博主在此发文（包括但不限于汉字、拼音、拉丁字母）均为随意敲击键盘所出，用于检验本人电脑键盘录入、屏幕显示的机械、光电性能，并不代表本人局部或全部同意、支持或者反对观点。如需要详查请直接与键盘生产厂商法人代表联系。挖井挑水无水表，不会网购无快递。 文章内容部分来源于互联网，不代表本人的任何立场；涉及到的软件来源于互联网，仅供个人下载使用，请勿用于商业用途，版权归软件开发者所有，下载后请于24小时内删除，如有真实需要请支持正版！因下载本站任何资源造成的损失，全部责任由使用者本人承担！如果你是版权方，认为本文内容对您的权益有所侵犯，请联系博主，并参照侵删联系的说明提交相应的证明材料，待博主进行严格地审查和背景调查后，情况属实的将在三天内将本文删除或修正。 博主的文章没有高度、深度和广度，只是凑字数。由于博主的水平不高（其实是个菜B），不足和错误之处在所难免，希望大家能够批评指出。 博主是利用读书、参考、引用、抄袭、复制和粘贴等多种方式打造成自己的纯镀 24k 文章，请原谅博主成为一个无耻的文档搬运工！ 博主只是一名普通的互联网从业者，不懂修电脑，不会卖电脑，不会帮你盗号，不会破解开机密码，找不回你丢失的手机等，如有这样的想法请绕道！ 本人企鹅号1608536443 本人邮箱qianxun0827@outlook.com]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
